# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../orm/tutorial.rst:5
msgid "Object Relational Tutorial"
msgstr "객체 관계형 튜토리얼"

#: ../../orm/tutorial.rst:7
msgid ""
"The SQLAlchemy Object Relational Mapper presents a method of associating user-"
"defined Python classes with database tables, and instances of those classes "
"(objects) with rows in their corresponding tables. It includes a system that "
"transparently synchronizes all changes in state between objects and their "
"related rows, called a :term:`unit of work`, as well as a system for "
"expressing database queries in terms of the user defined classes and their "
"defined relationships between each other."
msgstr ""
"SQLAlchemy ORM(Object Relational Mapper)은 사용자가 정의한 클래스를 테이터베이"
"스 테이블에, 그 클래스의 인스턴스를 해당 테이블의 행에 결합(매핑, mapping)시키는 메서드를 제공"
"한다. SQLAlchemy는 객체와 그와 관련된 행 사이의 모든 변화를 명확하게 동기화시키"
"는 시스템 즉, :term:`작업 단위 패턴`\ (unit of work) 시스템을 가지고 있다. 또"
"한 데이터베이스 쿼리를 사용자가 정의한 클래스와 클래스 사이에서 정의된 관계로 "
"표현할 수 있게 하는 시스템도 포함하고 있다."

#: ../../orm/tutorial.rst:15
msgid ""
"The ORM is in contrast to the SQLAlchemy Expression Language, upon which the "
"ORM is constructed. Whereas the SQL Expression Language, introduced in :ref:"
"`sqlexpression_toplevel`, presents a system of representing the primitive "
"constructs of the relational database directly without opinion, the ORM "
"presents a high level and abstracted pattern of usage, which itself is an "
"example of applied usage of the Expression Language."
msgstr ""
"ORM의 기반이 되는 SQLAlchemy 표현식 언어(expression language)와 ORM은 아주 다르"
"다. :ref:`sqlexpression_toplevel`\ 에서 소개할 SQL 표현식 언어는 관계형 데이"
"터 베이스의 원시적인 구조를 직접적으로 나타내지만 ORM은 표현식 언어를 응용한 고"
"수준의(high level) 사용법이라고 할 수 있다."

#: ../../orm/tutorial.rst:22
msgid ""
"While there is overlap among the usage patterns of the ORM and the Expression "
"Language, the similarities are more superficial than they may at first appear. "
"One approaches the structure and content of data from the perspective of a "
"user-defined :term:`domain model` which is transparently persisted and "
"refreshed from its underlying storage model. The other approaches it from the "
"perspective of literal schema and SQL expression representations which are "
"explicitly composed into messages consumed individually by the database."
msgstr ""
"ORM과 표현식 언어의 사용 패턴에는  공통점이 있을 수 있지만 둘 사이의 유사점은 "
"겉보기 뿐이다. ORM은 사용자가 정의한 :term:`domain model`\ 의 관점에서 데이터"
"의 내용과 구조에 접근한다. :term:`domain model`\ 은 내부에 감추어진 스토리지 "
"모형을 통해 투명하게 유지 및 갱신된다. 표현식 언어는 이와 반대로 리터럴 스키마"
"와 SQL 표현의 관점에서 접근한다. 표현식 언어는 데이터베이스에서 개별적으로 사용"
"되는 메세지로 구성된다. "

#: ../../orm/tutorial.rst:31
msgid ""
"A successful application may be constructed using the Object Relational Mapper "
"exclusively. In advanced situations, an application constructed with the ORM "
"may make occasional usage of the Expression Language directly in certain areas "
"where specific database interactions are required."
msgstr ""
"ORM만 사용해도 어플리케이션을 성공적으로 구성할 수 있다. 복잡한 경우에는 어플리"
"케이션을 ORM으로 구현한 뒤 특정 데이터베이스와의 상호작용이 필요한 부분에서만 "
"직접적으로 표현식 언어를 사용하기도 한다. "

#: ../../orm/tutorial.rst:36
msgid ""
"The following tutorial is in doctest format, meaning each ``>>>`` line "
"represents something you can type at a Python command prompt, and the "
"following text represents the expected return value."
msgstr ""
"아래의 튜토리얼은 doctest 형식이다. ``>>>`` 라인은 파이썬 커맨드 프롬프트에 입"
"력할 수 있다는 것을 뜻하고 그 아래의 텍스트는 예상되는 반환 값을 의미한다."

#: ../../orm/tutorial.rst:41
msgid "Version Check"
msgstr "버전 확인"

#: ../../orm/tutorial.rst:43
msgid ""
"A quick check to verify that we are on at least **version 1.3** of SQLAlchemy::"
msgstr "**1.3 버전** 이상의 SQLAlchemy를 사용하고 있는지 확인한다.::"

#: ../../orm/tutorial.rst:50
msgid "Connecting"
msgstr "연결"

#: ../../orm/tutorial.rst:52
msgid ""
"For this tutorial we will use an in-memory-only SQLite database. To connect we "
"use :func:`~sqlalchemy.create_engine`::"
msgstr ""
"이 튜로리얼에서 우리는 인메모리(in-memory-only) SQL 데이터베이스를 사용할 것이다. "
"연결을 위해서 :func:`~sqlalchemy.create_engine`\ 를 사용한다::"

#: ../../orm/tutorial.rst:58
msgid ""
"The ``echo`` flag is a shortcut to setting up SQLAlchemy logging, which is "
"accomplished via Python's standard ``logging`` module. With it enabled, we'll "
"see all the generated SQL produced. If you are working through this tutorial "
"and want less output generated, set it to ``False``. This tutorial will format "
"the SQL behind a popup window so it doesn't get in our way; just click the "
"\"SQL\" links to see what's being generated."
msgstr ""
"``echo`` 플래그는 SQLAlchemy가 로그를 보여주도록 하는 플래그로 로깅은 "
"파이썬의 표준 ``logging`` 모듈을 통해서 이루어진다. 이 플래그가 활성화되면 생성되는 모든 "
"SQL을 확인할 수 있다. 만약 이 튜토리얼을 하면서 출력이 적게 나오기를 바란다면 "
"``False``\ 로 설정하면 된다. 이렇게 하면 뒷단에서 SQL을 사용하므로 우"
"리가 로그 메세지로 방해받지 않는다. 어떤 SQL이 생성되었는지 확인하려면 \"SQL\" 링크"
"를 누르기만 하면 된다."

#: ../../orm/tutorial.rst:65
msgid ""
"The return value of :func:`.create_engine` is an instance of :class:`.Engine`, "
"and it represents the core interface to the database, adapted through a :term:"
"`dialect` that handles the details of the database and :term:`DBAPI` in use.  "
"In this case the SQLite dialect will interpret instructions to the Python "
"built-in ``sqlite3`` module."
msgstr ""
":func:`.create_engine`\ 의 반환 값은 :class:`.Engine`\ 의 인스턴스로 사용중"
"인 :term:`DBAPI`\ 와 데이터베이스의 세부사항을 처리하는 :term:`dialect`\ 를 "
"통해 적용된 데이터베이스 핵심 인터페이스를 나타낸다. 본 튜토리얼의 경우에는 "
"SQL dialect가 파이썬 내장 ``sqlite3`` 모듈에 대한 명령을 해석할 것이다. "

msgid "Lazy Connecting"
msgstr "지연 컨넥션"

#: ../../orm/tutorial.rst:74
msgid ""
"The :class:`.Engine`, when first returned by :func:`.create_engine`, has not "
"actually tried to connect to the database yet; that happens only the first "
"time it is asked to perform a task against the database."
msgstr ""
":class:`.Engine`\ 는 :func:`.create_engine`\ 에서 반환되었을 때에는 실제로 데"
"이터베이스에 연결을 시도하지 않는다. 실제 연결은 데이터베이스에 대한 작업을 수"
"행하도록 최초로 요청받았을 때 이루어진다."

#: ../../orm/tutorial.rst:78
msgid ""
"The first time a method like :meth:`.Engine.execute` or :meth:`.Engine."
"connect` is called, the :class:`.Engine` establishes a real :term:`DBAPI` "
"connection to the database, which is then used to emit the SQL.  When using "
"the ORM, we typically don't use the :class:`.Engine` directly once created; "
"instead, it's used behind the scenes by the ORM as we'll see shortly."
msgstr ""
":meth:`.Engine.execute` 또는 :meth:`.Engine.connect`\ 가 최초로 호출되면, :"
"class:`.Engine`\ 은 데이터베이스에 대한 실제 :term:`DBAPI` 연결을 만들고 SQL"
"을 내보내는 데 사용된다. ORM을 사용할 때, 우리는 보통 생성된 :class:`.Engine`"
"\ 를 직접적으로 사용하지 않는다. 엔진은 ORM에 의해 내부적으로 사용된다. 이 부"
"분은 곧 살펴볼 것이다."

#: ../../orm/tutorial.rst:86
msgid ""
":ref:`database_urls` - includes examples of :func:`.create_engine` connecting "
"to several kinds of databases with links to more information."
msgstr ""
":ref:`database_urls` - :func:`.create_engine`\ 로 다양한 데이터베이스에 연결하"
"는 예제 및 관련 정보에 대한 링크를 포함한다. "

#: ../../orm/tutorial.rst:90
msgid "Declare a Mapping"
msgstr "매핑 선언"

#: ../../orm/tutorial.rst:92
msgid ""
"When using the ORM, the configurational process starts by describing the "
"database tables we'll be dealing with, and then by defining our own classes "
"which will be mapped to those tables.   In modern SQLAlchemy, these two tasks "
"are usually performed together, using a system known as :ref:"
"`declarative_toplevel`, which allows us to create classes that include "
"directives to describe the actual database table they will be mapped to."
msgstr ""
"ORM을 사용할 때 최초 설정 과정은 데이터베이스 테이블을 구성하고 그 테이블에 매"
"핑 될 클래스를 정의하는 것이다. SQLAlchemy에서 이 두 작업은 선언(Declarative)"
"시스템이라는 것을 사용하여 한번에 실행한다. 이 시스템을 쓰"
"면 매핑할 실제 데이터베이스 테이블을 만드는 명령어를 포함하는 클래스를 생성할 "
"수 있다."

#: ../../orm/tutorial.rst:100
msgid ""
"Classes mapped using the Declarative system are defined in terms of a base "
"class which maintains a catalog of classes and tables relative to that base - "
"this is known as the **declarative base class**.  Our application will usually "
"have just one instance of this base in a commonly imported module.   We create "
"the base class using the :func:`.declarative_base` function, as follows::"
msgstr ""
"선언 시스템으로 만들어지는 클래스는 클래스를 만들때는 실제 테이블"
"과 클래스의 카탈로그를 관리하는 베이스 클래스 관점에서 정의된다. 이 베이스 클래"
"스를 **declarative base class**\ 라고 부른다. 보통은 공통 임포트 모듈에 이 베"
"이스 클래스의 인스턴스 하나를 만든다. 베이스 클래스는 :func:`.declarative_base`"
"\ 함수를 사용해서 다음처럼 생성한다:"

#: ../../orm/tutorial.rst:111
msgid ""
"Now that we have a \"base\", we can define any number of mapped classes in "
"terms of it.  We will start with just a single table called ``users``, which "
"will store records for the end-users using our application. A new class called "
"``User`` will be the class to which we map this table.  Within the class, we "
"define details about the table to which we'll be mapping, primarily the table "
"name, and names and datatypes of columns::"
msgstr ""
"일단 베이스 클래스가 있으면 이것에 관한 여러 개의 매핑된 클래스도 정의할 수 있"
"다. 우리는 ``users``\ 라는 이름의 테이블부터 만들 것이다. 이 테이블은 이 기능"
"을 사용하는 최종사용자를 위해 기록을 저장한다. ``User``\ 라고 불리는 새로운 클"
"래스는 이 테이블을 매핑하는 클래스이다. 이 클래스 내부에서 매핑할 테이블, 테이"
"블 이름 그리고 컬럼의 이름과 자료형에 대한 세부사항을 정의한다:"

msgid "Tip"
msgstr "팁"

#: ../../orm/tutorial.rst:133
msgid ""
"The ``User`` class defines a ``__repr__()`` method, but note that is "
"**optional**; we only implement it in this tutorial so that our examples show "
"nicely formatted ``User`` objects."
msgstr ""
"``User``\  클래스에서 ``__repr__()``\  메서드를 정의하지만 이는 **선택적인**"
"\  부분이다. 우리는이 튜토리얼에서 이를 구현하기 때문에 우리의 예제는 멋지게 "
"형식화 된 ``User``\  객체를 보여줄 것이다."

#: ../../orm/tutorial.rst:138
msgid ""
"A class using Declarative at a minimum needs a ``__tablename__`` attribute, "
"and at least one :class:`.Column` which is part of a primary key [#]_.  "
"SQLAlchemy never makes any assumptions by itself about the table to which a "
"class refers, including that it has no built-in conventions for names, "
"datatypes, or constraints.   But this doesn't mean boilerplate is required; "
"instead, you're encouraged to create your own automated conventions using "
"helper functions and mixin classes, which is described in detail at :ref:"
"`declarative_mixins`."
msgstr ""
"최소한으로 선언 시스템을 사용하는 클래스는 ``__tablename__``\ 속성과 기본 키 "
"[#]_\ 가 되는 하나 이상의 :class:`.Column`\ 이 있어야 한다. SQLAlchemy는 클래"
"스가 참조하는 테이블에 대해 어떠한 가정도 하지 않는다. 테이블 이름이나 데이터 "
"타입, 제약 사항에 대한 내장된 관례도 없다. 그렇다고 템플릿이 있어야 하는 것도 "
"아니다. 대신 helper 함수와 mixin 클래스들을 이용해서 자신만의 자동화된 관례를 "
"만들 수 있다. :ref:`declarative_mixins`\ 를 참고하라."

#: ../../orm/tutorial.rst:148
msgid ""
"When our class is constructed, Declarative replaces all the :class:`.Column` "
"objects with special Python accessors known as :term:`descriptors`; this is a "
"process known as :term:`instrumentation`.   The \"instrumented\" mapped class "
"will provide us with the means to refer to our table in a SQL context as well "
"as to persist and load the values of columns from the database."
msgstr ""
"클래스를 구성할 때, 선언 시스템은 모든 :class:`.Column`\  객체를 :term:"
"`descriptors`\ 라는 파이썬 접근자로 대체한다. 이를 :term:`instrumentation`\ "
"이라고 한다. 매핑된 “instrumented” 클래스는 SQL 컨텍스트에서 테이블을 참조하여 "
"컬럼 값을 불러오고 유지할 수 있는 메서드를 제공한다."

#: ../../orm/tutorial.rst:154
msgid ""
"Outside of what the mapping process does to our class, the class remains "
"otherwise mostly a normal Python class, to which we can define any number of "
"ordinary attributes and methods needed by our application."
msgstr ""
"매핑 과정에 클래스에 가해지는 작업만 제외하면 이 클래스는 일반적인 파이썬 클래"
"스와 같으므로 이 클래스에 우리의 어플리케이션에서 필요한 다른 메서드와 속성도 "
"정의할 수 있다."

#: ../../orm/tutorial.rst:158
msgid ""
"For information on why a primary key is required, see :ref:"
"`faq_mapper_primary_key`."
msgstr ""
"기본 키가 왜 요구되는지에 대해서는 :ref:`faq_mapper_primary_key`\ 를 참고하라."

#: ../../orm/tutorial.rst:163
msgid "Create a Schema"
msgstr "스키마 생성"

#: ../../orm/tutorial.rst:165
msgid ""
"With our ``User`` class constructed via the Declarative system, we have "
"defined information about our table, known as :term:`table metadata`.   The "
"object used by SQLAlchemy to represent this information for a specific table "
"is called the :class:`.Table` object, and here Declarative has made one for "
"us.  We can see this object by inspecting the ``__table__`` attribute::"
msgstr ""
"선언 시스템을 통해 생성된 ``User``\  클래스로 테이블에 대한 정보(:term:`table "
"metadata`\ )를 정의할 수 있었다. 특정 테이블에 대한 실제 데이터는 :class:`."
"Table`\  객체로 표현되는데 SQLAlchemy는 이 객체를 자동 생성한다. 이 객체는 클"
"래스의 ``__table__``\  속성을 통해 확인할 수 있다::"

msgid "Classical Mappings"
msgstr "클래식 맵핑"

#: ../../orm/tutorial.rst:179
msgid ""
"The Declarative system, though highly recommended, is not required in order to "
"use SQLAlchemy's ORM. Outside of Declarative, any plain Python class can be "
"mapped to any :class:`.Table` using the :func:`.mapper` function directly; "
"this less common usage is described at :ref:`classical_mapping`."
msgstr ""
"선언 시스템을 사용하는 것을 적극 추천하지만 SQLAlchemy의 ORM 사용에서 필수적인 "
"것은 아니다. 덜 사용하는 방법이긴 하지만 선언시스템 외에 일반 파이썬 클래스에 :"
"func:`.mapper`\  함수를 사용하여 :class:`.Table`\ 로 맵핑할 수도 있다. 이 방"
"법은 클래식 매핑(:ref:`classical_mapping`\ )에서 설명한다."

#: ../../orm/tutorial.rst:186
msgid ""
"When we declared our class, Declarative used a Python metaclass in order to "
"perform additional activities once the class declaration was complete; within "
"this phase, it then created a :class:`.Table` object according to our "
"specifications, and associated it with the class by constructing a :class:`."
"Mapper` object.  This object is a behind-the-scenes object we normally don't "
"need to deal with directly (though it can provide plenty of information about "
"our mapping when we need it)."
msgstr ""
"선언 시스템은 일단 클래스 선언이 완료되면 추가적인 작동을 수행하기 위해 파이썬 "
"메타클래스를 사용한다. 이 때, 설정에 따라 :class:`.Table`\ 객체를 생성하고 그 "
"다음으로 :class:`.Mapper`\  객체를 생성함으로써 둘을 결합시킨다. :class:`."
"Mapper`\  객체는 뒷단에 있는 객체이며 보통 직접 다루지 않는다. (필요한 경우 매"
"핑에 대한 많은 정보를 제공해주기는 한다)."

#: ../../orm/tutorial.rst:194
msgid ""
"The :class:`.Table` object is a member of a larger collection known as :class:"
"`.MetaData`.  When using Declarative, this object is available using the ``."
"metadata`` attribute of our declarative base class."
msgstr ""
":class:`.Table` 객체는 :class:`.MetaData`\ 라는 더 큰 집합의 구성원이다. 선언 "
"시스템을 사용한다면 선언용 베이스 클래스의 ``.metadata`` 속성으로 이 객체에 접"
"근할 수 있다."

#: ../../orm/tutorial.rst:199
msgid ""
"The :class:`.MetaData` is a :term:`registry` which includes the ability to "
"emit a limited set of schema generation commands to the database.  As our "
"SQLite database does not actually have a ``users`` table present, we can use :"
"class:`.MetaData` to issue CREATE TABLE statements to the database for all "
"tables that don't yet exist. Below, we call the :meth:`.MetaData.create_all` "
"method, passing in our :class:`.Engine` as a source of database connectivity.  "
"We will see that special commands are first emitted to check for the presence "
"of the ``users`` table, and following that the actual ``CREATE TABLE`` "
"statement:"
msgstr ""
":class:`.MetaData`\ 는 제한된 수의 스키마 생성 명령어 집합을 데이터베이스로 보"
"내기 위한 기능을 포함하는 레지스트리( :term:`registry`\ )이다. 현재 우리의 "
"SQLite 데이터베이스는 실제로 ``users``\  테이블을 가지고 있지 않기 때문에 아"
"직 존재하지 않는 모든 테이블에 대해 CREATE TABLE 명령을 데이터베이스에 내리기위"
"해 :class:`.MetaData`\ 를 사용할 것이다. 다음 코드에서 보듯이 :meth:`."
"MetaData.create_all`\  메서드를 호출하고 :class:`.Engine`\  인수를 데이터베이"
"스 연결 소스로서 전달했다. ``user``\  테이블의 존재를 확인하기 위한 특별 명령"
"이 먼저 발행되고 다음으로 실제 ``CREATE TABLE``\  명령이 전달되는 것을 보게 "
"될 것이다:"

msgid "Minimal Table Descriptions vs. Full Descriptions"
msgstr "테이블 최소 기술과 전체 기술"

#: ../../orm/tutorial.rst:226
msgid ""
"Users familiar with the syntax of CREATE TABLE may notice that the VARCHAR "
"columns were generated without a length; on SQLite and PostgreSQL, this is a "
"valid datatype, but on others, it's not allowed. So if running this tutorial "
"on one of those databases, and you wish to use SQLAlchemy to issue CREATE "
"TABLE, a \"length\" may be provided to the :class:`~sqlalchemy.types.String` "
"type as below::"
msgstr ""
"CREATE TABLE 문법에 익숙한 사용자는 VARCHAR 컬럼이 길이 제한 없이 생성된 것을 "
"알아차렸을 것이다. 이 방식은 SQLite나 PostegreSQL에서는 유효하지만, 다른 데이터"
"베이스 시스템에서는 그렇지 않다. 따라서 이 튜토리얼을 SQLite나 PostegreSQL가 아"
"닌 다른 데이터베이스에서 실행하는 경우에는 CREATE TABLE 명령을 실행할 때 문자"
"열 길이를 :class:`~sqlalchemy.types.String`\  자료형에 다음처럼 제공해야 한"
"다::"

#: ../../orm/tutorial.rst:235
msgid ""
"The length field on :class:`~sqlalchemy.types.String`, as well as similar "
"precision/scale fields available on :class:`~sqlalchemy.types.Integer`, :class:"
"`~sqlalchemy.types.Numeric`, etc. are not referenced by SQLAlchemy other than "
"when creating tables."
msgstr ""
":class:`~sqlalchemy.types.String`\ 의 length 필드와 :class:`~sqlalchemy.types."
"Integer’\ , :class:`~sqlalchemy.types.Numeric`\  등에서 이용 가능한 "
"precision/scale 필드는 테이블을 생성할 때를 제외하고는 SQLAlchemy에 의해 참조되"
"지 않는다."

#: ../../orm/tutorial.rst:239
msgid ""
"Additionally, Firebird and Oracle require sequences to generate new primary "
"key identifiers, and SQLAlchemy doesn't generate or assume these without being "
"instructed. For that, you use the :class:`~sqlalchemy.schema.Sequence` "
"construct::"
msgstr ""
"추가적으로, Firebird와 Oracle은 새로운 기본 키를 만들 때 시퀀스(sequence)가 필"
"요한데 SQLAlchemy는 명시적 지시없이는 시퀀스를 생성하지 않는다. 시퀀스를 만들려"
"면 :class:`~sqlalchemy.schema.Sequence`\ 를 사용한다::"

#: ../../orm/tutorial.rst:246
msgid ""
"A full, foolproof :class:`~sqlalchemy.schema.Table` generated via our "
"declarative mapping is therefore::"
msgstr ""
"선언적 매핑을 통해 생성된 전체 :class:`~sqlalchemy.schema.Table`\  클래스는 다"
"음과 같다::"

#: ../../orm/tutorial.rst:260
msgid ""
"We include this more verbose table definition separately to highlight the "
"difference between a minimal construct geared primarily towards in-Python "
"usage only, versus one that will be used to emit CREATE TABLE statements on a "
"particular set of backends with more stringent requirements."
msgstr ""
"파이썬 내에서만 테이블 클래스를 쓸 때는 이렇게 할 필요가 없지만 여기에서는 더 "
"엄격한 요구사항이 있는 특정 백엔드 데이터베이스에서 CREATE TABLE 명령을 실행할 "
"때를 대비하여 보다 상세한 테이블 정의를 해 보았다."

#: ../../orm/tutorial.rst:267
msgid "Create an Instance of the Mapped Class"
msgstr "매핑된 클래스의 인스턴스 생성"

#: ../../orm/tutorial.rst:269
msgid "With mappings complete, let's now create and inspect a ``User`` object::"
msgstr "매핑을 완료했으면, ``User``\  객체를 생성하고 검사해보자::"

msgid "the ``__init__()`` method"
msgstr "``__init__()``\  메서드"

#: ../../orm/tutorial.rst:282
msgid ""
"Our ``User`` class, as defined using the Declarative system, has been provided "
"with a constructor (e.g. ``__init__()`` method) which automatically accepts "
"keyword names that match the columns we've mapped.    We are free to define "
"any explicit ``__init__()`` method we prefer on our class, which will override "
"the default method provided by Declarative."
msgstr ""
"선언 시스템을 이용해 정의된 ``User``\  클래스의 생성자(``__init__()``\  메서"
"드)는 자동적으로 우리가 매핑해놓은 컬럼과 일치하는 속성을 가진다. 명시적으로 "
"``__init__()``\ 메서드를 정의할 수도 있다. 이 경우에는 선언 시스템에 의해 제공"
"된 기본 메서드를 덮어쓰게 된다."

#: ../../orm/tutorial.rst:288
msgid ""
"Even though we didn't specify it in the constructor, the ``id`` attribute "
"still produces a value of ``None`` when we access it (as opposed to Python's "
"usual behavior of raising ``AttributeError`` for an undefined attribute). "
"SQLAlchemy's :term:`instrumentation` normally produces this default value for "
"column-mapped attributes when first accessed.    For those attributes where "
"we've actually assigned a value, the instrumentation system is tracking those "
"assignments for use within an eventual INSERT statement to be emitted to the "
"database."
msgstr ""
"(보통 파이썬에서 정의되지 않은 속성을 사용하면 ``AttributionError``\ 가 발생하"
"는 것과 달리) 여기에서는 생성자에서 지정하지 않은 ``id``\  속성이 자동으로 "
"``None``\  값이 된다. SQLAlchemy의 인스트루멘테이션(:term:`instrumentation`"
"\ )은 일반적으로 컬럼에 매핑된 속성에 처음 접근했을 때 디폴트 값을 생성한다. "
"실제로 값이 할당된 속성은 데이터베이스에 보내질 최종적인 INSERT 명령문에서 사용"
"될 수 있도록 인스트루멘테이션 시스템이 계속 추적한다."

#: ../../orm/tutorial.rst:298
msgid "Creating a Session"
msgstr "세션 생성"

#: ../../orm/tutorial.rst:300
msgid ""
"We're now ready to start talking to the database. The ORM's \"handle\" to the "
"database is the :class:`~sqlalchemy.orm.session.Session`. When we first set up "
"the application, at the same level as our :func:`~sqlalchemy.create_engine` "
"statement, we define a :class:`~sqlalchemy.orm.session.Session` class which "
"will serve as a factory for new :class:`~sqlalchemy.orm.session.Session` "
"objects::"
msgstr ""
"이제 데이터베이스와 대화할 준비가 되었다. 데이터베이스에 대한 ORM의 핸들"
"(handle)은 :class:`~sqlalchemy.orm.session.Session`\ 이다. :func:`~sqlalchemy."
"create_engine`\ 명령으로 처음 어플리케이션을 셋업할 때, :class:`~sqlalchemy."
"orm.session.Session`\  객체용 팩토리로 사용할 :class:`~sqlalchemy.orm.session."
"Session`\  클래스를 정의한다."

#: ../../orm/tutorial.rst:310
msgid ""
"In the case where your application does not yet have an :class:`~sqlalchemy."
"engine.Engine` when you define your module-level objects, just set it up like "
"this::"
msgstr ""
"만약 어플리케이션에 :class:`~sqlalchemy.engine.Engine`\ 이 없는 경우에는 모듈"
"에서 그냥 다음처럼 설정해도 된다::"

#: ../../orm/tutorial.rst:316
msgid ""
"Later, when you create your engine with :func:`~sqlalchemy.create_engine`, "
"connect it to the :class:`~sqlalchemy.orm.session.Session` using :meth:`~."
"sessionmaker.configure`::"
msgstr ""
"이 때는 나중에 :func:`~sqlalchemy.create_engine`\ 으로 엔진 객체를 만들고 :"
"meth:`~.sessionmaker.configure`\ 를 사용해서 엔진을 :class:`~sqlalchemy.orm."
"session.Session`\ 에 연결할 수 있다::"

msgid "Session Lifecycle Patterns"
msgstr "세션 생애 주기 패턴"

#: ../../orm/tutorial.rst:324
msgid ""
"The question of when to make a :class:`.Session` depends a lot on what kind of "
"application is being built.  Keep in mind, the :class:`.Session` is just a "
"workspace for your objects, local to a particular database connection - if you "
"think of an application thread as a guest at a dinner party, the :class:`."
"Session` is the guest's plate and the objects it holds are the food (and the "
"database...the kitchen?)!  More on this topic available at :ref:"
"`session_faq_whentocreate`."
msgstr ""
"언제 :class:`.Session`\ 을 만들어야 하는가 하는 질문은 어떤 종류의 어플리케이"
"션을 만들고 있나에 따라 다르다. :class:`.Session`\ 는 로컬에서 특정한 데이터베"
"이스에 연결하는 객체를 위한 작업 공간일 뿐이라는 점을 명심해라. 만약 어플리케이"
"션 쓰레드를 디너 파티의 게스트라고 생각한다면 :class:`.Session`\ 은 게스트의 "
"접시에 불과하고 클래스가 담고있는 객체가 실제 음식이다! (그리고 데이터베이스는 "
"… 부엌?) 이 주제에 대한 보다 자세한 정보는 :ref:`session_faq_whentocreate`\ "
"를 참조한다."

#: ../../orm/tutorial.rst:333
msgid ""
"This custom-made :class:`~sqlalchemy.orm.session.Session` class will create "
"new :class:`~sqlalchemy.orm.session.Session` objects which are bound to our "
"database. Other transactional characteristics may be defined when calling :"
"class:`~.sessionmaker` as well; these are described in a later chapter. Then, "
"whenever you need to have a conversation with the database, you instantiate a :"
"class:`~sqlalchemy.orm.session.Session`::"
msgstr ""
"이 :class:`~sqlalchemy.orm.session.Session`\  클래스는 우리의 데이터베이스에 "
"바인딩된 :class:`~sqlalchemy.orm.session.Session`\  객체를 생성한다. 기타 트랜"
"잭션 특성은 :class:`~.sessionmaker`\ 을 호출할 때 정의된다; 이 부분은 이후의 "
"챕터에서 설명할 것이다. 이제부터는 데이터베이스와 통신 하고 싶을 때마다 :class:"
"`~sqlalchemy.orm.session.Session`\ 를 인스턴스화 해야 한다:"

#: ../../orm/tutorial.rst:342
msgid ""
"The above :class:`~sqlalchemy.orm.session.Session` is associated with our "
"SQLite-enabled :class:`.Engine`, but it hasn't opened any connections yet. "
"When it's first used, it retrieves a connection from a pool of connections "
"maintained by the :class:`.Engine`, and holds onto it until we commit all "
"changes and/or close the session object."
msgstr ""
"위의 :class:`~sqlalchemy.orm.session.Session`\ 은 SQLite :class:`.Engine`\ "
"과 바인딩되어 있지만 아직 어떠한 연결도 열려있지 않다. 최초로 session을 사용할 "
"때 :class:`.Engine`\ 에 의해 유지된 컨넥션 풀에서 컨넥션을 획득하여 모든 변경"
"사항을 커밋하고 session 객체를 닫기 전까지 연결을 유지한다."

#: ../../orm/tutorial.rst:350
msgid "Adding and Updating Objects"
msgstr "객체의 추가 및 갱신"

#: ../../orm/tutorial.rst:352
msgid ""
"To persist our ``User`` object, we :meth:`~.Session.add` it to our :class:"
"`~sqlalchemy.orm.session.Session`::"
msgstr ""
"``User``\  객체를 영구보존하기 위해서, :class:`~sqlalchemy.orm.session."
"Session`\ 에 :meth:`~.Session.add`\ 로 객체를 추가한다:"

#: ../../orm/tutorial.rst:357
msgid ""
"At this point, we say that the instance is **pending**; no SQL has yet been "
"issued and the object is not yet represented by a row in the database.  The :"
"class:`~sqlalchemy.orm.session.Session` will issue the SQL to persist ``Ed "
"Jones`` as soon as is needed, using a process known as a **flush**. If we "
"query the database for ``Ed Jones``, all pending information will first be "
"flushed, and the query is issued immediately thereafter."
msgstr ""
"이 시점에서 우리는 인스턴스가 **pending**\  상태라고 한다; SQL은 아직 출력되"
"지 않았으며 객체는 아직 데이터베이스의 행으로 나타나지 않았다. :class:"
"`~sqlalchemy.orm.session.Session`\ 는 필요한 경우 **flush**\  라는 과정을 통"
"해 즉시 ``Ed Jones``\ 를 데이터베이스에 입력하는 SQL을 생성한다. 만약 데이터베"
"이스에 ``Ed Jones``\ 를 쿼리한다면 먼저 대기중인 정보가 데이터베이스에 입력되"
"고 그 다음에야 쿼리가 실행된다."

#: ../../orm/tutorial.rst:364
msgid ""
"For example, below we create a new :class:`~sqlalchemy.orm.query.Query` object "
"which loads instances of ``User``. We \"filter by\" the ``name`` attribute of "
"``ed``, and indicate that we'd like only the first result in the full list of "
"rows. A ``User`` instance is returned which is equivalent to that which we've "
"added:"
msgstr ""
"예를 들어, 다음처럼 :class:`~sqlalchemy.orm.query.Query`\  객체를 사용하여 "
"``User``\ 의 인스턴스를 불러올 수 있다. ``ed``\ 의 ``name``\  속성으로 필터링"
"된 결과에서 첫 번째 것만 받아오도록 했다. 이렇게 하면 우리가 추가했던 것과 똑같"
"은 ``User``\  인스턴스가 반환된다::"

#: ../../orm/tutorial.rst:387
msgid ""
"In fact, the :class:`~sqlalchemy.orm.session.Session` has identified that the "
"row returned is the **same** row as one already represented within its "
"internal map of objects, so we actually got back the identical instance as "
"that which we just added::"
msgstr ""
"사실 :class:`~sqlalchemy.orm.session.Session`\ 는 반환할 행이 객체의 내부 맵"
"에 있는 것과 **동일한** 행이라는 것을 알고 있다. 그래서 우리는 실제로 우리가 추"
"가한 것과 동일한 인스턴스를 돌려 받게 된다::"

#: ../../orm/tutorial.rst:395
msgid ""
"The ORM concept at work here is known as an :term:`identity map` and ensures "
"that all operations upon a particular row within a :class:`~sqlalchemy.orm."
"session.Session` operate upon the same set of data. Once an object with a "
"particular primary key is present in the :class:`~sqlalchemy.orm.session."
"Session`, all SQL queries on that :class:`~sqlalchemy.orm.session.Session` "
"will always return the same Python object for that particular primary key; it "
"also will raise an error if an attempt is made to place a second, already-"
"persisted object with the same primary key within the session."
msgstr ""
"여기서 동작하는 ORM 개념은 :term:`identity map`\ 이다. identity map은 :class:"
"`~sqlalchemy.orm.session.Session`\  세션에 있는 특정 행에 대한 모든 작업이 같"
"은 데이터 셋에서 작동함을 보장한다. 일단 특정한 기본 키가 :class:`~sqlalchemy."
"orm.session.Session`\ 에 있으면 :class:`~sqlalchemy.orm.session.Session`\ 의 "
"모든 SQL 쿼리는 항상 특정한 기본 키에 대해 동일한 파이썬 객체를 반환한다. 또한 "
"세션 내에서 동일한 기본 키를 이미 보유중인 두 번째 객체를 배치하려고 시도하면 "
"에러가 발생한다."

#: ../../orm/tutorial.rst:406
msgid ""
"We can add more ``User`` objects at once using :func:`~sqlalchemy.orm.session."
"Session.add_all`:"
msgstr ""
":func:`~sqlalchemy.orm.session.Session.add_all`\ 를 이용해서 ``User``\  객체"
"를 한 번에 추가할 수 있다:"

msgid ""
"Also, we've decided Ed's nickname isn't that great, so lets change it:"
msgstr ""
"또한 Ed의 닉네임이 별로 좋지 않다고 생각한다면 다음처럼 바꿀 수 있다.:"

#: ../../orm/tutorial.rst:422
msgid ""
"The :class:`~sqlalchemy.orm.session.Session` is paying attention. It knows, "
"for example, that ``Ed Jones`` has been modified:"
msgstr ""
":class:`~sqlalchemy.orm.session.Session`\ 는 계속 변경 추적을 한다. 예를 들"
"어, 세션은 ``Ed Jones``\ 가 변경됐다는 것을 안다:"

#: ../../orm/tutorial.rst:430
msgid "and that three new ``User`` objects are pending:"
msgstr "그리고 새로운 3개의 ``User`` 객체가 대기중이라는 것도 알고 있다::"

#: ../../orm/tutorial.rst:439
msgid ""
"We tell the :class:`~sqlalchemy.orm.session.Session` that we'd like to issue "
"all remaining changes to the database and commit the transaction, which has "
"been in progress throughout. We do this via :meth:`~.Session.commit`.  The :"
"class:`~sqlalchemy.orm.session.Session` emits the ``UPDATE`` statement for the "
"nickname change on \"ed\", as well as ``INSERT`` statements for the three new "
"``User`` objects we've added:"
msgstr ""
":meth:`~.Session.commit`\  명령을 사용하면 :class:`~sqlalchemy.orm.session."
"Session`\ 에 모든 남아있는 변경 사항을 수정하는 트랜잭션을 커밋한다. 실제로 :"
"class:`~sqlalchemy.orm.session.Session`\ 가 “ed”의 닉네임을 변경하는 "
"``UPDATE``\  명령과, 추가한 3개의 새로운 ``User``\  객체를 삽입하는 "
"``INSERT``\  명령을 내보내는 것을 볼 수 있다.:"

#: ../../orm/tutorial.rst:459
msgid ""
":meth:`~.Session.commit` flushes the remaining changes to the database, and "
"commits the transaction. The connection resources referenced by the session "
"are now returned to the connection pool. Subsequent operations with this "
"session will occur in a **new** transaction, which will again re-acquire "
"connection resources when first needed."
msgstr ""
":meth:`~.Session.commit`\ 은 남아있는 변경 사항을 데이터베이스로 보내고 트랜잭"
"션을 커밋한다. 작업이 끝나면 세션에 의해 참조된 컨넥션 리소스는 연결 풀로 반환"
"된다. 이 세션을 사용하여 또다른 작업을 하면 새로운 트랜잭션 안에서 실행되고 컨"
"넥션 리소스도 필요한 시점에 다시 획득한다."

#: ../../orm/tutorial.rst:465
msgid ""
"If we look at Ed's ``id`` attribute, which earlier was ``None``, it now has a "
"value:"
msgstr "이전에 ``None``\ 이었던 Ed 의 ``id``\  속성은 이제 값을 가지고 있다:"

#: ../../orm/tutorial.rst:480
msgid ""
"After the :class:`~sqlalchemy.orm.session.Session` inserts new rows in the "
"database, all newly generated identifiers and database-generated defaults "
"become available on the instance, either immediately or via load-on-first-"
"access. In this case, the entire row was re-loaded on access because a new "
"transaction was begun after we issued :meth:`~.Session.commit`. SQLAlchemy by "
"default refreshes data from a previous transaction the first time it's "
"accessed within a new transaction, so that the most recent state is available. "
"The level of reloading is configurable as is described in :doc:`/orm/session`."
msgstr ""
":class:`~sqlalchemy.orm.session.Session`\ 가 데이터베이스에 새로운 행을 삽입하"
"면 인스턴스에서 새롭게 생성된 식별자들과 데이터베이스 생성 기본 값이 즉시 혹은 "
"최초로 접근할 때 준비된다. 이 때에는 :meth:`~.Session.commit`\ 을 실행한 뒤에 "
"새로운 트랜잭션이 시작되었기 때문에 전체 행이 다시 로드된다. SQLAlchemy는 기본"
"적으로 이전 트랜잭션으로부터 얻은 데이터를 새로운 트랜잭션에서 사용할 때는 다"
"시 데이터를 리로드(reload)해서 가장 최신 데이터를 이용할 수 있게 해준다. 리로"
"드 수준은 :doc:`/orm/session`\ 에서 설명하는대로 조정할 수 있다."

msgid "Session Object States"
msgstr "세션 객체의 상태"

#: ../../orm/tutorial.rst:491
msgid ""
"As our ``User`` object moved from being outside the :class:`.Session`, to "
"inside the :class:`.Session` without a primary key, to actually being "
"inserted, it moved between three out of four available \"object states\" - "
"**transient**, **pending**, and **persistent**. Being aware of these states "
"and what they mean is always a good idea - be sure to read :ref:"
"`session_object_states` for a quick overview."
msgstr ""
"``User``\  객체가 :class:`.Session`\  밖에서, :class:`.Session`\  안으로 기"
"본 키 없이 이동하면서 삽입되었고, 4가지 중 3가지의 가능한 “객체 상태” (**임시"
"(transient)**, **대기(pending)**, **영속(persistent)**) 사이에서 움직였다. 이 "
"상태들과 그 의미를 알고 있는 것은 도움이 되므로 :ref:`session_object_states`\ "
"에 있는 간단한 설명을 읽어 보기 바란다."

#: ../../orm/tutorial.rst:499
msgid "Rolling Back"
msgstr "롤백"

#: ../../orm/tutorial.rst:500
msgid ""
"Since the :class:`~sqlalchemy.orm.session.Session` works within a transaction, "
"we can roll back changes made too. Let's make two changes that we'll revert; "
"``ed_user``'s user name gets set to ``Edwardo``:"
msgstr ""
":class:`~sqlalchemy.orm.session.Session`\ 은 트랜잭션 내에서 작동하기 때문에 "
"변경한 것을 롤백할 수도 있다. 되돌릴 변경 사항 두 개를 만들어보자; ``ed_user``"
"\ 의 사용자 이름을 ``Edwardo``\ 로 설정한다::"

#: ../../orm/tutorial.rst:508
msgid "and we'll add another erroneous user, ``fake_user``:"
msgstr "그리고 잘못 입력된 사용자, ``fake_user``\ 를 추가한다::"

#: ../../orm/tutorial.rst:515
msgid ""
"Querying the session, we can see that they're flushed into the current "
"transaction:"
msgstr ""
"세션으로 쿼리를 하면, 변경 사항이 현재의 트랜잭션으로 들어간 것을 확인할 수 있"
"다::"

#: ../../orm/tutorial.rst:533
msgid ""
"Rolling back, we can see that ``ed_user``'s name is back to ``ed``, and "
"``fake_user`` has been kicked out of the session:"
msgstr ""
"롤백하면, ``ed_user``\ 의 이름이 ``ed``\ 로 돌아가고 ``fake_user``\ 가 세션"
"에서 사라지는 것을 확인할 수 있다."

#: ../../orm/tutorial.rst:555
msgid "issuing a SELECT illustrates the changes made to the database:"
msgstr "SELECT를 이용하면 데이터베이스에서 생성된 변경 사항을 볼 수 있다::"

#: ../../orm/tutorial.rst:572
msgid "Querying"
msgstr "쿼리"

#: ../../orm/tutorial.rst:574
msgid ""
"A :class:`~sqlalchemy.orm.query.Query` object is created using the :class:"
"`~sqlalchemy.orm.session.Session.query()` method on :class:`~sqlalchemy.orm."
"session.Session`. This function takes a variable number of arguments, which "
"can be any combination of classes and class-instrumented descriptors. Below, "
"we indicate a :class:`~sqlalchemy.orm.query.Query` which loads ``User`` "
"instances. When evaluated in an iterative context, the list of ``User`` "
"objects present is returned:"
msgstr ""
":class:`~sqlalchemy.orm.query.Query`\  객체는 :class:`~sqlalchemy.orm.session."
"Session`\ 의 :class:`~sqlalchemy.orm.session.Session.query()`\  메서드를 사용"
"해 생성할 수 있다. 이 함수는 어떤 클래스와 클래스 인스트루먼트 디스크립터의 조"
"합도 인수로 넣을 수 있고 인수의 갯수도 상관없다. 아래는 ``User``\  인스턴스를 "
"불러오는 :class:`~sqlalchemy.orm.query.Query`\ 다. 이 객체를 iteration 컨텍스"
"트에서 evaluation하면, 모든 ``User``\  객체의 리스트를 반환한다."

#: ../../orm/tutorial.rst:598
msgid ""
"The :class:`~sqlalchemy.orm.query.Query` also accepts ORM-instrumented "
"descriptors as arguments. Any time multiple class entities or column-based "
"entities are expressed as arguments to the :class:`~sqlalchemy.orm.session."
"Session.query()` function, the return result is expressed as tuples:"
msgstr ""
":class:`~sqlalchemy.orm.query.Query`\ 는 인수로 ORM 인스트루먼트 디스크립터도 "
"받을 수 있다. 다중 클래스 엔티티나 컬럼 기반 엔티티가 :class:`~sqlalchemy.orm."
"session.Session.query()`\ 에 인수로 전달되면 반환 결과는 튜플로 나타난다::"

#: ../../orm/tutorial.rst:617
msgid ""
"The tuples returned by :class:`~sqlalchemy.orm.query.Query` are *named* "
"tuples, supplied by the :class:`.KeyedTuple` class, and can be treated much "
"like an ordinary Python object. The names are the same as the attribute's name "
"for an attribute, and the class name for a class:"
msgstr ""
":class:`~sqlalchemy.orm.query.Query`\ 로 반환되는 튜플은 *명명된*\  튜플이"
"며, :class:`.KeyedTuple`\ 클래스로 제공되고 일반 파이썬 객체처럼 다루어진다. "
"속성의 속성 이름과, 클래스의 클래스 이름은 동일하다::"

#: ../../orm/tutorial.rst:638
msgid ""
"You can control the names of individual column expressions using the :meth:`~."
"ColumnElement.label` construct, which is available from any :class:`."
"ColumnElement`-derived object, as well as any class attribute which is mapped "
"to one (such as ``User.name``):"
msgstr ""
"개별 컬럼 표현식의 이름은 :meth:`~.ColumnElement.label`\  구조를 사용해 조정"
"할 수 있으며 이 구조는 :class:`.ColumnElement`\  파생 객체와 하나의 클래스에 "
"맵핑된 클래스 속성(예, ``User.name``)에서 사용할 수 있다::"

#: ../../orm/tutorial.rst:655
msgid ""
"The name given to a full entity such as ``User``, assuming that multiple "
"entities are present in the call to :meth:`~.Session.query`, can be controlled "
"using :func:`~.sqlalchemy.orm.aliased` :"
msgstr ""
":meth:`~.Session.query`\  호출할 때 복수의 엔티티가 있는 경우에는 ``User``\  "
"같은 전체 엔티티에 주어진 이름을 :func:`~.sqlalchemy.orm.aliased`\ 를 사용해 "
"제어할 수 있다::"

#: ../../orm/tutorial.rst:677
msgid ""
"Basic operations with :class:`~sqlalchemy.orm.query.Query` include issuing "
"LIMIT and OFFSET, most conveniently using Python array slices and typically in "
"conjunction with ORDER BY:"
msgstr ""
"파이썬 배열 슬라이싱을 써서 :class:`~sqlalchemy.orm.query.Query`\ 에 LIMIT과 "
"OFFSET 옵션을 포함시킬 수 있고 ORDER BY와 함께 쓸 수도 있다::"

#: ../../orm/tutorial.rst:695
msgid ""
"and filtering results, which is accomplished either with :func:`~sqlalchemy."
"orm.query.Query.filter_by`, which uses keyword arguments:"
msgstr ""
":func:`~sqlalchemy.orm.query.Query.filter_by`\ 에 키워드 인수를 넣어 결과를 필"
"터링할 수도 있다.::"

#: ../../orm/tutorial.rst:708
msgid ""
"...or :func:`~sqlalchemy.orm.query.Query.filter`, which uses more flexible SQL "
"expression language constructs. These allow you to use regular Python "
"operators with the class-level attributes on your mapped class:"
msgstr ""
"더 유연한 SQL 표현식 언어 구조를 사용하는 :func:`~sqlalchemy.orm.query.Query."
"filter`\ 를 사용할 수도 있다. 이 경우 매핑된 클래스의 클래스 수준 속성과 함께 "
"일반 파이썬 연산자도 쓸 수 있다.::"

#: ../../orm/tutorial.rst:722
msgid ""
"The :class:`~sqlalchemy.orm.query.Query` object is fully **generative**, "
"meaning that most method calls return a new :class:`~sqlalchemy.orm.query."
"Query` object upon which further criteria may be added. For example, to query "
"for users named \"ed\" with a full name of \"Ed Jones\", you can call :func:"
"`~sqlalchemy.orm.query.Query.filter` twice, which joins criteria using ``AND``:"
msgstr ""
":class:`~sqlalchemy.orm.query.Query`\  객체는 완전히 **생성적(generative)**"
"\  이다. 즉, 대부분의 메서드 호출 결과는 :class:`~sqlalchemy.orm.query.Query`"
"\  객체로 반환된다. 따라서 다음처럼 조건을 더 추가시킬 수 있다. 예를 들어 전"
"체 이름이 “Ed Jones”고 이름이 “ed”인 사용자를 쿼리하고 싶으면, :func:"
"`~sqlalchemy.orm.query.Query.filter`\ 를 두 번 호출하면 되며, 조건은 ``AND``"
"\ 를 사용하여 결합된다:"


#: ../../orm/tutorial.rst:745
msgid "Common Filter Operators"
msgstr "자주 쓰이는 필터 연산자"

#: ../../orm/tutorial.rst:747
msgid ""
"Here's a rundown of some of the most common operators used in "
":func:`~sqlalchemy.orm.query.Query.filter`:"
msgstr ""
"아래는 :func:`~sqlalchemy.orm.query.Query.filter` 에서 가장 "
"일반적으로 쓰이는 연산자 목록이다:"

#: ../../orm/tutorial.rst:750
msgid ":meth:`equals <.ColumnOperators.__eq__>`::"
msgstr ":meth:`equals <.ColumnOperators.__eq__>`::"

#: ../../orm/tutorial.rst:754
msgid ":meth:`not equals <.ColumnOperators.__ne__>`::"
msgstr ":meth:`not equals <.ColumnOperators.__ne__>`::"

#: ../../orm/tutorial.rst:758
msgid ":meth:`LIKE <.ColumnOperators.like>`::"
msgstr ":meth:`LIKE <.ColumnOperators.like>`::"

#: ../../orm/tutorial.rst:762
msgid ""
":meth:`.ColumnOperators.like` renders the LIKE operator, which is case "
"insensitive on some backends, and case sensitive on others.  For "
"guaranteed case-insensitive comparisons, use "
":meth:`.ColumnOperators.ilike`."
msgstr ""
":meth:`.ColumnOperators.like`\ 는 LIKE 연산자를 렌더링하며,"
"몇몇 백엔드에서는 대소문자를 구별하지 않고, 몇몇 백엔드에서는 "
"대소문자를 구별한다. 대소문자를 구별하지 않는 비교를 하려면 "
":meth:`.ColumnOperators.ilike`\ 를 사용하라."

#: ../../orm/tutorial.rst:767
msgid ":meth:`ILIKE <.ColumnOperators.ilike>` (case-insensitive LIKE)::"
msgstr ":meth:`ILIKE <.ColumnOperators.ilike>` (case-insensitive LIKE)::"

#: ../../orm/tutorial.rst:771
msgid ""
"most backends don't support ILIKE directly.  For those, the "
":meth:`.ColumnOperators.ilike` operator renders an expression combining "
"LIKE with the LOWER SQL function applied to each operand."
msgstr ""
"대부분의 백엔드는 ILIKE를 직접적으로 지원하지 않는다. 그런 경우 "
":meth:`.ColumnOperators.ilike` 연산자는 LIKE를 각 피연산자에 적용된 "
"하위 레벨 SQL 함수와 결합한 표현으로 렌더링한다."

#: ../../orm/tutorial.rst:775
msgid ":meth:`IN <.ColumnOperators.in_>`::"
msgstr ":meth:`IN <.ColumnOperators.in_>`::"

#: ../../orm/tutorial.rst:784
msgid ":meth:`NOT IN <.ColumnOperators.notin_>`::"
msgstr ":meth:`NOT IN <.ColumnOperators.notin_>`::"

#: ../../orm/tutorial.rst:788
msgid ":meth:`IS NULL <.ColumnOperators.is_>`::"
msgstr ":meth:`IS NULL <.ColumnOperators.is_>`::"

#: ../../orm/tutorial.rst:795
msgid ":meth:`IS NOT NULL <.ColumnOperators.isnot>`::"
msgstr ":meth:`IS NOT NULL <.ColumnOperators.isnot>`::"

#: ../../orm/tutorial.rst:802
msgid ":func:`AND <.sql.expression.and_>`::"
msgstr ":func:`AND <.sql.expression.and_>`::"

#: ../../orm/tutorial.rst:814
msgid "Make sure you use :func:`.and_` and **not** the Python ``and`` operator!"
msgstr "파이썬 ``and`` 연산자가 **아니라** :func:`.and_`\ 를 사용하고 있는지 확인하라."

#: ../../orm/tutorial.rst:817
msgid ":func:`OR <.sql.expression.or_>`::"
msgstr ":func:`OR <.sql.expression.or_>`::"

#: ../../orm/tutorial.rst:822
msgid "Make sure you use :func:`.or_` and **not** the Python ``or`` operator!"
msgstr "파이썬 ``or`` 연산자가 아니라 :func:`.or_`\ 를 사용하고 있는지 확인하라."

#: ../../orm/tutorial.rst:825
msgid ":meth:`MATCH <.ColumnOperators.match>`::"
msgstr ":meth:`MATCH <.ColumnOperators.match>`::"

#: ../../orm/tutorial.rst:831
msgid ""
":meth:`~.ColumnOperators.match` uses a database-specific ``MATCH`` or "
"``CONTAINS`` function; its behavior will vary by backend and is not "
"available on some backends such as SQLite."
msgstr ""
":meth:`~.ColumnOperators.match`\ 는 특정 데이터베이스만 제공하는 ``MATCH`` 명령이나 "
"``CONTAINS`` 함수를 사용한다. 이 동작은 백엔드에 따라 다르며, "
"SQLite 같은 몇몇 백엔드에서는 사용할 수 없다."

#: ../../orm/tutorial.rst:836
msgid "Returning Lists and Scalars"
msgstr "리스트와 스칼라 반환"

#: ../../orm/tutorial.rst:838
msgid ""
"A number of methods on :class:`.Query` immediately issue SQL and return a"
" value containing loaded database results.  Here's a brief tour:"
msgstr ""
":class:`.Query`\ 의 메서드 대부분은 즉시 SQL을 출력하고 "
"로드된 데이터베이스 결과를 포함하는 값을 반환한다. 아래는 간단한 예시이다:"

#: ../../orm/tutorial.rst:842
msgid ":meth:`~.Query.all()` returns a list:"
msgstr ":meth:`~.Query.all()`\ 는 리스트를 반환한다:"

#: ../../orm/tutorial.rst:858
msgid ""
":meth:`~.Query.first()` applies a limit of one and returns the first "
"result as a scalar:"
msgstr ""
":meth:`~.Query.first()`\는 limit를 하나로 정하여 첫 번째 결과만 "
"스칼라로 반환한다:"

#: ../../orm/tutorial.rst:874
msgid ""
":meth:`~.Query.one()` fully fetches all rows, and if not exactly one "
"object identity or composite row is present in the result, raises an "
"error.  With multiple rows found:"
msgstr ""
":meth:`~.Query.one()`\ 는 모든 행을 완전히 불러오고, "
"정확한 객체 행이나 복합 객체 행이 결과에 존재하지 않으면 에러를 발생시킨다. "
"여러 행이 찾아진 경우:"

#: ../../orm/tutorial.rst:885
msgid "With no rows found:"
msgstr "찾아진 행이 없는 경우:"

#: ../../orm/tutorial.rst:894
msgid ""
"The :meth:`~.Query.one` method is great for systems that expect to handle"
" \"no items found\" versus \"multiple items found\" differently; such as "
"a RESTful web service, which may want to raise a \"404 not found\" when "
"no results are found, but raise an application error when multiple "
"results are found."
msgstr ""
":meth:`~.Query.one` 메서드는 \"no items found\"와 \"multiple items found\"를 다르게 "
"처리하기 원하는 시스템에 쓸모가 있다; 예를 들어, "
"찾은 결과가 하나도 없을 때는 \"404 not found\"를 발생키길 원하고 "
"찾은 결과가 하나이면 어플리케이션 에러를 발생시키기 원하는 RESTful 웹서비스를 만들 때 "
"유용하다."

#: ../../orm/tutorial.rst:899
msgid ""
":meth:`~.Query.one_or_none` is like :meth:`~.Query.one`, except that if "
"no results are found, it doesn't raise an error; it just returns "
"``None``. Like :meth:`~.Query.one`, however, it does raise an error if "
"multiple results are found."
msgstr ""
":meth:`~.Query.one_or_none`\ 는 :meth:`~.Query.one`\ 와 비슷하지만,"
"결과를 찾지 못했을 때 에러를 발생시키지 않고 그냥 ``None`` 값을 반환한다."
"그러나, :meth:`~.Query.one` 처럼"
"여러 결과를 찾았을 경우 에러를 발생시킨다."

#: ../../orm/tutorial.rst:904
msgid ""
":meth:`~.Query.scalar` invokes the :meth:`~.Query.one` method, and upon "
"success returns the first column of the row:"
msgstr ""
":meth:`~.Query.scalar`\ 는 :meth:`~.Query.one` 메서드를 불러오며, "
"성공시에 행의 첫 번째 컬럼을 반환한다:"

#: ../../orm/tutorial.rst:921
msgid "Using Textual SQL"
msgstr "텍스트형 SQL 사용"

#: ../../orm/tutorial.rst:923
msgid ""
"Literal strings can be used flexibly with "
":class:`~sqlalchemy.orm.query.Query`, by specifying their use with the "
":func:`~.expression.text` construct, which is accepted by most applicable"
" methods.  For example, :meth:`~sqlalchemy.orm.query.Query.filter()` and "
":meth:`~sqlalchemy.orm.query.Query.order_by()`:"
msgstr ""
":func:`~.expression.text` 생성자를 사용하면 "
":class:`~sqlalchemy.orm.query.Query`\ 에서 리터럴 스트링을 쓸 수 있다. "
":func:`~.expression.text`\ 는 "
":meth:`~sqlalchemy.orm.query.Query.filter()`\ 와 "
":meth:`~sqlalchemy.orm.query.Query.order_by()`\ 를 포함한 대부분의 메서드에 적용 가능하다."

#: ../../orm/tutorial.rst:949
msgid ""
"Bind parameters can be specified with string-based SQL, using a colon. To"
" specify the values, use the :meth:`~sqlalchemy.orm.query.Query.params()`"
" method:"
msgstr ""
"바인드 파라미터(bind parameter)는 콜론을 써서 스트링 기반 SQL로 지정할 수 있다. "
"이 때는 :meth:`~sqlalchemy.orm.query.Query.params()` "
"메서드로 값을 지정한다.:"

#: ../../orm/tutorial.rst:966
msgid ""
"To use an entirely string-based statement, a :func:`.text` construct "
"representing a complete statement can be passed to "
":meth:`~sqlalchemy.orm.query.Query.from_statement()`.  Without additional"
" specifiers, the columns in the string SQL are matched to the model "
"columns based on name, such as below where we use just an asterisk to "
"represent loading all columns:"
msgstr ""
"명령 전체를 감싸는 :func:`.text` 생성자를 "
":meth:`~sqlalchemy.orm.query.Query.from_statement()`\ 에 전달하면 "
"순수한 SQL 명령 문자열을 쓸 수 있다. 추가적인 지정자가 없어도 "
"SQL 문자열에 있는 컬럼은 해당 이름에 기반한 모델 컬럼과 매치된다. "
"예를 들어 아래에서는 별표를 사용하여 "
"모든 컬럼을 로드하였다:"

#: ../../orm/tutorial.rst:982
msgid ""
"Matching columns on name works for simple cases but can become unwieldy "
"when dealing with complex statements that contain duplicate column names "
"or when using anonymized ORM constructs that don't easily match to "
"specific names. Additionally, there is typing behavior present in our "
"mapped columns that we might find necessary when handling result rows.  "
"For these cases, the :func:`~.expression.text` construct allows us to "
"link its textual SQL to Core or ORM-mapped column expressions "
"positionally; we can achieve this by passing column expressions as "
"positional arguments to the :meth:`.TextClause.columns` method:"
msgstr ""
"간단한 경우에는 테이블 컬럼과 문자열 내의 이름이 일치하지만 "
"중복된 컬럼 이름을 포함하는 복잡한 명령을 처리하거나 "
"특정 이름과 쉽게 일치하지 않는 익명화된 ORM을 사용할 때는 "
"매칭이 어려워질 수 있다. "
"또, 결과 행들을 처리할 때 필요하다고 판단되는 매핑된 컬럼에 존재하는 타이핑 동작이 "
"있을 수도 있다. "
"이 때는 :func:`~.expression.text` 생성자가 텍스트 형식 SQL을 위치에 따라 "
"Core나 ORM-매핑된 컬럼 표현식에 연결해준다. "
"컬럼 표현식을 위치 인수로 :meth:`.TextClause.columns`\ 에 전달하면 된다."

#: ../../orm/tutorial.rst:1004
msgid ""
"The :meth:`.TextClause.columns` method now accepts column expressions "
"which will be matched positionally to a plain text SQL result set, "
"eliminating the need for column names to match or even be unique in the "
"SQL statement."
msgstr ""
":meth:`.TextClause.columns` 메서드는 현재 일반 텍스트 SQL 결과 집합에 "
"일치하게 될 컬럼 표현식을 인수의 위치(순서)로 확인하므로 "
"SQL 명령에서 컬럼 이름이 동일하거나 유니크해야 할 "
"필요가 없어졌다."

#: ../../orm/tutorial.rst:1009
msgid ""
"When selecting from a :func:`~.expression.text` construct, the "
":class:`.Query` may still specify what columns and entities are to be "
"returned; instead of ``query(User)`` we can also ask for the columns "
"individually, as in any other case:"
msgstr ""
":func:`~.expression.text`\ 를 써서 쿼리를 할 때도 "
":class:`.Query`\ 는 여전히 반환될 엔티티와 컬럼을 지정할 수 있다. "
"다른 경우처럼 ``query(User)``\ 를 쓰는 대신에 "
"컬럼을 개별적으로 요청할 수도 있다:"

#: ../../orm/tutorial.rst:1026
msgid ""
":ref:`sqlexpression_text` - The :func:`.text` construct explained from "
"the perspective of Core-only queries."
msgstr ""
":ref:`sqlexpression_text` - Core 전용 쿼리 관점에서 설명된 "
":func:`.text` 구조."

#: ../../orm/tutorial.rst:1030
msgid "Counting"
msgstr "카운팅"

#: ../../orm/tutorial.rst:1032
msgid ""
":class:`~sqlalchemy.orm.query.Query` includes a convenience method for "
"counting called :meth:`~sqlalchemy.orm.query.Query.count()`:"
msgstr ""
":class:`~sqlalchemy.orm.query.Query`\ 는 카운팅을 위한 편리한 메서드인 "
":meth:`~sqlalchemy.orm.query.Query.count()`\ 을 포함하고 있다:"

msgid "Counting on ``count()``"
msgstr "count()로 카운트하기"

#: ../../orm/tutorial.rst:1050
msgid ""
":meth:`.Query.count` used to be a very complicated method when it would "
"try to guess whether or not a subquery was needed around the existing "
"query, and in some exotic cases it wouldn't do the right thing. Now that "
"it uses a simple subquery every time, it's only two lines long and always"
" returns the right answer.  Use ``func.count()`` if a particular "
"statement absolutely cannot tolerate the subquery being present."
msgstr ""
":meth:`.Query.count`\ 는 서브 쿼리가 기존 쿼리에 필요한지를 추측하려고 할 때는 "
"매우 복잡한 메서드가 됐었고 몇몇 특이한 경우에는 올바르게 작동하지 않았다. "
"이제 간단한 서브 쿼리를 사용하기 때문에 길이도 두 줄밖에 되지 않고 "
"항상 올바른 답을 반환한다. "
"특정한 명령이 서브 쿼리가 존재하는 것을 절대 용납하지 않는 경우 "
"``func.count()``\ 를 사용하라."

#: ../../orm/tutorial.rst:1058
msgid ""
"The :meth:`~.Query.count()` method is used to determine how many rows the"
" SQL statement would return.   Looking at the generated SQL above, "
"SQLAlchemy always places whatever it is we are querying into a subquery, "
"then counts the rows from that.   In some cases this can be reduced to a "
"simpler ``SELECT count(*) FROM table``, however modern versions of "
"SQLAlchemy don't try to guess when this is appropriate, as the exact SQL "
"can be emitted using more explicit means."
msgstr ""
":meth:`~.Query.count()` 메서드는 SQL 명령이 반환하는 행의 갯수를 알려준다. "
"위에서 생성된 SQL을 보면 SQLAlchemy는 항상 쿼리 하려는 것을 서브쿼리에 넣고, "
"그 결과으로부터 행을 센다. "
"몇몇 경우에는 더 간단한 ``SELECT count(*) FROM table``\ 로 축소될 수도 있다. "
"그러나, 최신 버전의 SQLAlchemy는 더 명시적인 수단을 사용해서 "
"정확한 SQL을 내보낼 수 있기 때문에 "
"이것이 언제 적헐한지를 추측하지 않는다"

#: ../../orm/tutorial.rst:1066
msgid ""
"For situations where the \"thing to be counted\" needs to be indicated "
"specifically, we can specify the \"count\" function directly using the "
"expression ``func.count()``, available from the "
":attr:`~sqlalchemy.sql.expression.func` construct.  Below we use it to "
"return the count of each distinct user name:"
msgstr ""
"특별히 어떤 것을 카운팅해야 하는지 명시해야 하는 경우에는 \"count\" 함수를 "
":attr:`~sqlalchemy.sql.expression.func`\ 에서 "
" ``func.count()`` 표현을 "
"사용해서 직접 지정할 수 있다. "
"아래에서는 각각의 user name의 카운트를 반환하기 위해서 사용했다:"

#: ../../orm/tutorial.rst:1081
msgid "To achieve our simple ``SELECT count(*) FROM table``, we can apply it as:"
msgstr "단순한 ``SELECT count(*) FROM table``\ 이 되도록 아래처럼 적용할 수도 있다:"

#: ../../orm/tutorial.rst:1091
msgid ""
"The usage of :meth:`~.Query.select_from` can be removed if we express the"
" count in terms of the ``User`` primary key directly:"
msgstr ""
"만약 ``User`` 기본 키를 직접 카운트하는 경우에는 "
":meth:`~.Query.select_from` 명령을 쓰지 않아도 된다.:"

#: ../../orm/tutorial.rst:1105
msgid "Building a Relationship"
msgstr "관계 만들기"

#: ../../orm/tutorial.rst:1107
msgid ""
"Let's consider how a second table, related to ``User``, can be mapped and"
" queried.  Users in our system can store any number of email addresses "
"associated with their username. This implies a basic one to many "
"association from the ``users`` to a new table which stores email "
"addresses, which we will call ``addresses``. Using declarative, we define"
" this table along with its mapped class, ``Address``:"
msgstr ""
"``User`` 테이블과 관련된 두 번째 테이블을 어떻게 매핑하고 쿼리할지 생각해보자. "
"User 테이블은 username과 연결된 이메일 주소를 저장할 수 있다. "
"이는 ``User``\ 에서 이메일 주소를 저장하는 새로운 테이블(``addresses``\ 로 부를 것이다) "
"로 향하는 기본적인 일대다 결합(one-to-many association)을 의미한다. "
"선언 시스템을 이용해 매핑된 클래스 "
"``Address``\ 와 함께 이 테이블을 정의한다:"

#: ../../orm/tutorial.rst:1133
msgid ""
"The above class introduces the :class:`.ForeignKey` construct, which is a"
" directive applied to :class:`.Column` that indicates that values in this"
" column should be :term:`constrained` to be values present in the named "
"remote column. This is a core feature of relational databases, and is the"
" \"glue\" that transforms an otherwise unconnected collection of tables "
"to have rich overlapping relationships. The :class:`.ForeignKey` above "
"expresses that values in the ``addresses.user_id`` column should be "
"constrained to those values in the ``users.id`` column, i.e. its primary "
"key."
msgstr ""
"위의 클래스는 :class:`.ForeignKey` 구조를 소개하고 있다. "
"이 구조는 :class:`.Column`\ 에 적용하는 명령어로 "
"이 컬럼에 있는 값은 반드시 지명된 외부의 컬럽에 존재하는 값과 :term:`constrained` "
"되어야 한다는 것을 나타낸다. 이것은 관계형 데이터베이스의 핵심 기능 중 하나로, "
"연결되지 않은 테이블 집합을 오버래핑된 풍부한 관계를 가질 수 있게 "
"변환시켜주는 접착제다. 위의 :class:`.ForeignKey`\ 는 "
"``addresses.user_id`` 컬럼에 있는 "
"값은 반드시 ``users.id`` 컬럼에 있는 값과 묶여있어야 한다는 것을 나타낸다. "
"즉, 일종의 기본 키다."

#: ../../orm/tutorial.rst:1142
msgid ""
"A second directive, known as :func:`.relationship`, tells the ORM that "
"the ``Address`` class itself should be linked to the ``User`` class, "
"using the attribute ``Address.user``. :func:`.relationship` uses the "
"foreign key relationships between the two tables to determine the nature "
"of this linkage, determining that ``Address.user`` will be :term:`many to"
" one`. An additional :func:`.relationship` directive is placed on the "
"``User`` mapped class under the attribute ``User.addresses``.  In both "
":func:`.relationship` directives, the parameter "
":paramref:`.relationship.back_populates` is assigned to refer to the "
"complementary attribute names; by doing so, each :func:`.relationship` "
"can make intelligent decision about the same relationship as expressed in"
" reverse;  on one side, ``Address.user`` refers to a ``User`` instance, "
"and on the other side, ``User.addresses`` refers to a list of ``Address``"
" instances."
msgstr ""
"두 번째 명령어 :func:`.relationship`\ 는 ORM에게 "
"``Address``\ 자체가 ``User`` 클래스와 "
"``Address.user`` 속성을 사용해 연결되어야 한다는 것을 말해준다. "
":func:`.relationship`\ 는 두 테이블 사이의 foreign key 관계를 사용해서 "
"``Address.user``\ 가 :term:`many to one`\ 이 되도록 하는 연결의 성질을 결정한다. "
"추가적인 :func:`.relationship` 명령어는 "
"매핑된 ``User`` 클래스의 ``User.addresses`` \ 속성에 위치한다. "
"두 :func:`.relationship` 명령 내에서 "
":paramref:`.relationship.back_populates` 변수는 상호간에 "
"속성 이름을 참조하기 위해서 할당된다; 그렇게 함으로써 각각의 :func:`.relationship`\ 은 "
"역으로 표현된 것과 같이 동일한 관계에 대한 "
"지능적인 결정을 할 수 있게 된다; "
"한 쪽에서 ``Address.user``\ 가 ``User`` 인스턴스를 참조하고, "
"다른 쪽에서 ``User.addresses`` 가 ``Address`` 인스턴스의 리스트를 "
"참조한다."

#: ../../orm/tutorial.rst:1160
msgid ""
"The :paramref:`.relationship.back_populates` parameter is a newer version"
" of a very common SQLAlchemy feature called "
":paramref:`.relationship.backref`.  The :paramref:`.relationship.backref`"
" parameter hasn't gone anywhere and will always remain available! The "
":paramref:`.relationship.back_populates` is the same thing, except a "
"little more verbose and easier to manipulate.  For an overview of the "
"entire topic, see the section :ref:`relationships_backref`."
msgstr ""
":paramref:`.relationship.back_populates`\ 는 가장 흔한 "
"QlAlchemy 특징인 :paramref:`.relationship.backref`\ 의 "
"새로운 버전이다. :paramref:`.relationship.backref` "
"변수는 사라지지 않았으며 앞으로도 사용가능할 것이다. "
":paramref:`.relationship.back_populates`\ 는 좀 더 상세하고 쉽게 조정할 수 있는 "
"점을 제외하고는 동일하다. 전체 내용에 대한 개요는 "
":ref:`relationships_backref` 섹션에서 볼 수 있다."

#: ../../orm/tutorial.rst:1168
msgid ""
"The reverse side of a many-to-one relationship is always :term:`one to "
"many`. A full catalog of available :func:`.relationship` configurations "
"is at :ref:`relationship_patterns`."
msgstr ""
"다대일 relationship의 반대는 :term:`one to many`\ 이다."
"사용가능한 전체 :func:`.relationship` 설정은 "
":ref:`relationship_patterns`\ 를 참고하라."

#: ../../orm/tutorial.rst:1172
msgid ""
"The two complementing relationships ``Address.user`` and "
"``User.addresses`` are referred to as a :term:`bidirectional "
"relationship`, and is a key feature of the SQLAlchemy ORM.   The section "
":ref:`relationships_backref` discusses the \"backref\" feature in detail."
msgstr ""
"두 보완적인 관계인 ``Address.user``\ 와 ``User.addresses``\ 는 "
":term:`bidirectional relationship`\ 로서 참조되며, "
"이는 SQLAlchemy ORM의 중요한 핵심적인 기능이다. "
":ref:`relationships_backref`\ 에서 \"backref\" 기능에 대해 자세하게 다루고 있다."

#: ../../orm/tutorial.rst:1177
msgid ""
"Arguments to :func:`.relationship` which concern the remote class can be "
"specified using strings, assuming the Declarative system is in use.   "
"Once all mappings are complete, these strings are evaluated as Python "
"expressions in order to produce the actual argument, in the above case "
"the ``User`` class.   The names which are allowed during this evaluation "
"include, among other things, the names of all classes which have been "
"created in terms of the declared base."
msgstr ""
"다른 클래스와 연관된 :func:`.relationship`\ 의 인수는 "
"Decalarative system이 사용중이면 문자열을 사용해서 지정할 수 있다. "
"모든 매핑이 완로되면, 이 문자열들은 실제 인수를 "
"생성하기 위한 파이썬 표현식으로 인식되며 위의 경우에서는 "
"``User`` 클래스가 된다. 평가 중에 허용되는 이름은 "
"선언된 base로 생성된 모든 클래스의 "
"이름을 포함한다."

#: ../../orm/tutorial.rst:1185
msgid ""
"See the docstring for :func:`.relationship` for more detail on argument "
"style."
msgstr ""
"인수 스타일에 대한 더 자세한 정보는 :func:`.relationship`\ 에 관한 "
"독스트링을 참고하라."

#: ../../orm/tutorial.rst:1189
msgid ""
"a FOREIGN KEY constraint in most (though not all) relational databases "
"can only link to a primary key column, or a column that has a UNIQUE "
"constraint."
msgstr ""
"대부분의 관계형 데이터베이스의 FOREIGN KEY 제약은 기본 키 컬럼이나, "
"UNIQUE 제약이 걸려있는 컬럼과만 "
"연결이 가능하다."

#: ../../orm/tutorial.rst:1191
msgid ""
"a FOREIGN KEY constraint that refers to a multiple column primary key, "
"and itself has multiple columns, is known as a \"composite foreign key\"."
"  It can also reference a subset of those columns."
msgstr ""
"여러 기본 키 컬럼을 참조하거나 여러 컬럼을 가지고 있는 FOREIGN KEY 제약은 "
"\"composite foreign key\"로 알려져 있다. "
"이 키는 위의 컬럼들의 하위 집합도 참조할 수 있다."

#: ../../orm/tutorial.rst:1194
msgid ""
"FOREIGN KEY columns can automatically update themselves, in response to a"
" change in the referenced column or row.  This is known as the CASCADE "
"*referential action*, and is a built in function of the relational "
"database."
msgstr ""
"FOREIGN KEY 컬럼은 참조하는 컬럼이나 행의 변화에 따라 "
"자동적으로 자기자신을 업데이트 한다. 이것은 CASCADE *referential action*\ 으로 "
"알려져있고, 관계형 데이터베이스의 "
"내장 함수다."

#: ../../orm/tutorial.rst:1197
msgid ""
"FOREIGN KEY can refer to its own table.  This is referred to as a \"self-"
"referential\" foreign key."
msgstr ""
"FOREIGN KEY\ 는 자신이 속한 테이블을 참조할 수 있다. "
"이것은 \"sefl_referential\" foreign key로 알려져 있다."

#: ../../orm/tutorial.rst:1199
msgid ""
"Read more about foreign keys at `Foreign Key - Wikipedia "
"<http://en.wikipedia.org/wiki/Foreign_key>`_."
msgstr ""
"`Foreign Key - Wikipedia <http://en.wikipedia.org/wiki/Foreign_key>`_\ 에서 "
"foreign key에 대한 더 자세한 내용을 확인할 수 있다."

#: ../../orm/tutorial.rst:1201
msgid ""
"We'll need to create the ``addresses`` table in the database, so we will "
"issue another CREATE from our metadata, which will skip over tables which"
" have already been created:"
msgstr ""
"우리는 데이터베이스에 ``addresses`` 테이블을 만들어야할 필요가 있다. "
"그래서 우리의 metadata로부터 또다른 CREATE 명령을 내보낼 것이고, "
"이 때 이미 생성된 테이블은 알아서 스킵될 것이다."

#: ../../orm/tutorial.rst:1220
msgid "Working with Related Objects"
msgstr "관계형 객체로 작업"

#: ../../orm/tutorial.rst:1222
msgid ""
"Now when we create a ``User``, a blank ``addresses`` collection will be "
"present. Various collection types, such as sets and dictionaries, are "
"possible here (see :ref:`custom_collections` for details), but by "
"default, the collection is a Python list."
msgstr ""
"``User``\ 가 생성될 때, 비어있는 ``addresses`` 컬렉션이 존재한다. "
"집합이나 딕셔너리 형태 등의 다양한 컬렉션 타입이 가능하지만 (자세한 내용은 "
":ref:`custom_collections`\ 를 확인하라) 기본적으로는 파이썬 리스트다. "

#: ../../orm/tutorial.rst:1233
msgid ""
"We are free to add ``Address`` objects on our ``User`` object. In this "
"case we just assign a full list directly:"
msgstr ""
"우리는 자유롭게 ``Address`` 객체를 ``User`` 객체에 추가할 수 있다. "
"이 경우 리스트 전체를 직접 할당할 것이다:"

#: ../../orm/tutorial.rst:1242
msgid ""
"When using a bidirectional relationship, elements added in one direction "
"automatically become visible in the other direction.  This behavior "
"occurs based on attribute on-change events and is evaluated in Python, "
"without using any SQL:"
msgstr ""
"bidirectional relationship을 사용할 때, 한 방향에서 추가된 요소는 자동적으로 "
"다른 방향에서 보이게 된다. 이 동작은 "
"변경시 속성에 기반해 발생하며 평가는 SQL을 사용하지 않고 "
"파이썬으로 이루어진다:"

#: ../../orm/tutorial.rst:1255
msgid ""
"Let's add and commit ``Jack Bean`` to the database. ``jack`` as well as "
"the two ``Address`` members in the corresponding ``addresses`` collection"
" are both added to the session at once, using a process known as "
"**cascading**:"
msgstr ""
"``Jack Bean``\ 를 데이터베이스에 추가하고 커밋하자. "
"**cascading**\ 이라는 프로세스를 사용해서 ``addresses``\ 에 해당하는 "
"두 ``Address`` 멤버 뿐만 아니라 "
"``jack``\ 둘 다 세션에 한 번에 추가된다:"

#: ../../orm/tutorial.rst:1272
msgid ""
"Querying for Jack, we get just Jack back.  No SQL is yet issued for "
"Jack's addresses:"
msgstr ""
"Jack에 대해 쿼리하면 Jack을 돌려받는다. "
"아직 Jack의 addresses에 대한 SQL은 발행되지 않았다:"

#: ../../orm/tutorial.rst:1290
msgid "Let's look at the ``addresses`` collection.  Watch the SQL:"
msgstr "``addresses`` 컬렉션을 보자. SQL을 보아라:"

#: ../../orm/tutorial.rst:1304
msgid ""
"When we accessed the ``addresses`` collection, SQL was suddenly issued. "
"This is an example of a :term:`lazy loading` relationship.  The "
"``addresses`` collection is now loaded and behaves just like an ordinary "
"list.  We'll cover ways to optimize the loading of this collection in a "
"bit."
msgstr ""
"``addresses`` 컬렉션에 액세스 할 때, SQL이 갑자기 발행된다. "
"이것은 :term:`lazy loading` relationship의 한 예이다. "
"``addresses`` 컬렉션이 이제 로드됐고 일반적인 리스트처럼 동작한다. "
"잠시 뒤에 이 컬렉션 로딩을 최척화 하는 법을 "
"다룰 것이다."

#: ../../orm/tutorial.rst:1312
msgid "Querying with Joins"
msgstr "Join 쿼리"

#: ../../orm/tutorial.rst:1314
msgid ""
"Now that we have two tables, we can show some more features of "
":class:`.Query`, specifically how to create queries that deal with both "
"tables at the same time. The `Wikipedia page on SQL JOIN "
"<http://en.wikipedia.org/wiki/Join_%28SQL%29>`_ offers a good "
"introduction to join techniques, several of which we'll illustrate here."
msgstr ""
"이제 두 테이블이 있기 때문에 :class:`.Query`\ 의 더 많은 기능들을 볼 수 있다. "
"특히 동시에 두 테이블을 다루는 커리를 만드는 방법을 보게 될 것이다. "
"`Wikipedia page on SQL JOIN <http://en.wikipedia.org/wiki/Join_%28SQL%29>`_\ 은 "
" 여기서 소게 할 몇몇 join 테크닉에 대한 "
"좋은 소개를 제공해준다."

#: ../../orm/tutorial.rst:1320
msgid ""
"To construct a simple implicit join between ``User`` and ``Address``, we "
"can use :meth:`.Query.filter()` to equate their related columns together."
" Below we load the ``User`` and ``Address`` entities at once using this "
"method:"
msgstr ""
"``Join``\ 과 ``Address``\ 사이에 간단한 암시적 join을 생성하기 위해서 "
"우리는 관계된 컬럼을 동일시하는 :meth:`.Query.filter()`\ 를 사용할 것이다. "
"아래에서 우리는 ``User``\ 와 ``Address``\ 개체를 "
"이 메서드를 사용해 한 번에 로드했다:"

#: ../../orm/tutorial.rst:1346
msgid ""
"The actual SQL JOIN syntax, on the other hand, is most easily achieved "
"using the :meth:`.Query.join` method:"
msgstr ""
"반면에, 실제 SQL JOIN 신택스는, "
":meth:`.Query.join` 메서드를 사용해 쉽게 만들 수 있다:"

#: ../../orm/tutorial.rst:1363
msgid ""
":meth:`.Query.join` knows how to join between ``User`` and ``Address`` "
"because there's only one foreign key between them. If there were no "
"foreign keys, or several, :meth:`.Query.join` works better when one of "
"the following forms are used::"
msgstr ""
":meth:`.Query.join`\ 는 ``User``\ 과 ``Address``\ 를 join하는 방법을 알고 있다. "
"왜냐하면 둘 사이에는 단 하나의 foreign key가 존재하기 때문이다. "
"foreign key가 없거나,여러개 있다면 아래의 형식을 사용했을 때, "
":meth:`.Query.join`\ 가 더 잘 작동한다::"

#: ../../orm/tutorial.rst:1373
msgid ""
"As you would expect, the same idea is used for \"outer\" joins, using the"
" :meth:`~.Query.outerjoin` function::"
msgstr ""
"예상했다시피 같은 아이디어가 :meth:`~.Query.outerjoin`\ 함수를 통해 "
"\"outer\" join에서도 사용된다::"

#: ../../orm/tutorial.rst:1378
msgid ""
"The reference documentation for :meth:`~.Query.join` contains detailed "
"information and examples of the calling styles accepted by this method; "
":meth:`~.Query.join` is an important method at the center of usage for "
"any SQL-fluent application."
msgstr ""
":meth:`~.Query.join`\ 에 대한 참고 문서는 상세한 정보와 "
"이 메서드에 의해 용인되는 호출 스타일에 대한 예시를 담고 있다; "
":meth:`~.Query.join`\ 은 SQL-fluent 어플리케이션 사용의 중심에 있는 "
"중요한 메서드다."

msgid "What does :class:`.Query` select from if there's multiple entities?"
msgstr "만약 여러 개의 개체가 있을 경우 어떤 :class:`.Query`\ 가 선택되어야 하는가?"

#: ../../orm/tutorial.rst:1384
msgid ""
"The :meth:`.Query.join` method will **typically join from the leftmost "
"item** in the list of entities, when the ON clause is omitted, or if the "
"ON clause is a plain SQL expression.  To control the first entity in the "
"list of JOINs, use the :meth:`.Query.select_from` method::"
msgstr ""
":meth:`.Query.join` 메서드는 ON clause가 생략됐을 때나, ON cluase가 일반 SQL 표현식일 때, "
"개체 리스트에 있는 **일반적으로 가장 촤측의 항목에서 join한다** JOIN의 리스트에 있는 첫 번째 "
"개체를 조작하고 싶으면 :meth:`.Query.select_from` 메서드를 사용하라::"

#: ../../orm/tutorial.rst:1395
msgid "Using Aliases"
msgstr "Alias 사용"

#: ../../orm/tutorial.rst:1397
msgid ""
"When querying across multiple tables, if the same table needs to be "
"referenced more than once, SQL typically requires that the table be "
"*aliased* with another name, so that it can be distinguished against "
"other occurrences of that table. The :class:`~sqlalchemy.orm.query.Query`"
" supports this most explicitly using the :attr:`~sqlalchemy.orm.aliased` "
"construct. Below we join to the ``Address`` entity twice, to locate a "
"user who has two distinct email addresses at the same time:"
msgstr ""
"여러 테이블에 걸친 쿼리를 할 때, 같은 테이블이 한 번 이상 참조되어야 한다면, SQL은 일반적으로 "
"해당 테이블을 다른 이름으로 *aliased*\ 할 것을 요구하며 이를 통해서 그 테이블이 다른 곳에서 "
"등장하는 것을 구분할 수 있다. :class:`~sqlalchemy.orm.query.Query`\ 는 이것을 "
":attr:`~sqlalchemy.orm.aliased` 구조를 사용해서 아주 명시적으로 지원한다. "
"아래에서 우리는 ``Address`` 개체를 두 번 join 시켜서, 두 개의 다른 이메일 주소를 가진 사용자를 "
"동시에 찾아냈다:"

#: ../../orm/tutorial.rst:1430
msgid "Using Subqueries"
msgstr "서브쿼리 사용"

#: ../../orm/tutorial.rst:1432
msgid ""
"The :class:`~sqlalchemy.orm.query.Query` is suitable for generating "
"statements which can be used as subqueries. Suppose we wanted to load "
"``User`` objects along with a count of how many ``Address`` records each "
"user has. The best way to generate SQL like this is to get the count of "
"addresses grouped by user ids, and JOIN to the parent. In this case we "
"use a LEFT OUTER JOIN so that we get rows back for those users who don't "
"have any addresses, e.g.::"
msgstr ""
":class:`~sqlalchemy.orm.query.Query`\ 는 서브 쿼리로 사용될 수 있는 명령을 생성하는 데도 적합하다. "
"``User`` 객체를 각 user가 몇 개의 ``Address`` 기록을 가지고 있는지 카운트 한 결과와 같이 "
"로드하고 싶다고 가정하자. SQL을 생성하기 가장 좋은 방법은 카운팅된 addresses를 user id로 group by해서 얻고 "
"부모에 JOIN 시키는 것이다. 이 경우 우리는 LEFT OUTER JOIN을 사용했고 addresses가 없는 "
"user 행을 돌려 받았다::"

#: ../../orm/tutorial.rst:1444
msgid ""
"Using the :class:`~sqlalchemy.orm.query.Query`, we build a statement like"
" this from the inside out. The ``statement`` accessor returns a SQL "
"expression representing the statement generated by a particular "
":class:`~sqlalchemy.orm.query.Query` - this is an instance of a "
":func:`~.expression.select` construct, which are described in "
":ref:`sqlexpression_toplevel`::"
msgstr ""
":class:`~sqlalchemy.orm.query.Query`\ 를 사용해서, 이러한 명령을 내부에서 밖으로 생성할 수 있다. "
"``statement`` 접근자는 특정한 :class:`~sqlalchemy.orm.query.Query`\ 에 의해 생성된 명령을 나타내는 "
"SQL 표현식을 반환한다. - 이것은 :func:`~.expression.select` 구조의 인스턴스이며 "
":ref:`sqlexpression_toplevel`\ 에 설명되어 있다::"

#: ../../orm/tutorial.rst:1455
msgid ""
"The ``func`` keyword generates SQL functions, and the ``subquery()`` "
"method on :class:`~sqlalchemy.orm.query.Query` produces a SQL expression "
"construct representing a SELECT statement embedded within an alias (it's "
"actually shorthand for ``query.statement.alias()``)."
msgstr ""
"``func`` 키워드는 SQL 함수를 생성하고 :class:`~sqlalchemy.orm.query.Query`\ 의 ``subquery()`` 메서드는 "
"alias로 임베디드된 SELECT 명령을 나타내는 SQL 표현식 구조를 생성한다 (이것은 사실 ``query.statement.alias()``\ 의 "
"축약형이다)."

#: ../../orm/tutorial.rst:1460
msgid ""
"Once we have our statement, it behaves like a "
":class:`~sqlalchemy.schema.Table` construct, such as the one we created "
"for ``users`` at the start of this tutorial. The columns on the statement"
" are accessible through an attribute called ``c``:"
msgstr ""
"명령문을 만들면, 이 명령문은 ``users`` 때문에 튜토리얼 첫 부분에서 만들었던 :class:`~sqlalchemy.schema.Table` "
"구조처럼 동작한다. 명령문의 컬럼은 ``c``\ 라고 하는 속성을 통해 접근할 수 있다:"

#: ../../orm/tutorial.rst:1488
msgid "Selecting Entities from Subqueries"
msgstr "서브 쿼리에서 개체 선택"

#: ../../orm/tutorial.rst:1490
msgid ""
"Above, we just selected a result that included a column from a subquery. "
"What if we wanted our subquery to map to an entity ? For this we use "
"``aliased()`` to associate an \"alias\" of a mapped class to a subquery:"
msgstr ""
"위에서 우리는 서브쿼리의 컬럼을 포함하는 결과를 select했다. "
"만약 서브 쿼리를 개체에 매핑하려면 어떻게 해야 할까? 이 경우 매핑된 클래스의 \"alias\"를 "
"서브 쿼리에 ``alisased()``\ 를 사용해서 결합하면 된다:"

#: ../../orm/tutorial.rst:1523
msgid "Using EXISTS"
msgstr "EXISTS 사용"

#: ../../orm/tutorial.rst:1525
msgid ""
"The EXISTS keyword in SQL is a boolean operator which returns True if the"
" given expression contains any rows. It may be used in many scenarios in "
"place of joins, and is also useful for locating rows which do not have a "
"corresponding row in a related table."
msgstr ""
"SQL의 EXISTS 키워드는 불리언 연산자로 주어진 표현식이 행을 포함하고 있으면 "
"참을 반환한다. 이것은 join을 대체해서 많은 시나리오에서 사용될 수 있으며 연결된 "
"테이블에 대응하는 행이 없는 행을 찾을 때에도 유용하다."

#: ../../orm/tutorial.rst:1530
msgid "There is an explicit EXISTS construct, which looks like this: "
msgstr "아래와 같이 보이는 명시적 EXISTS 구조도 있다:"

#: ../../orm/tutorial.rst:1546
msgid ""
"The :class:`~sqlalchemy.orm.query.Query` features several operators which"
" make usage of EXISTS automatically. Above, the statement can be "
"expressed along the ``User.addresses`` relationship using "
":meth:`~.RelationshipProperty.Comparator.any`:"
msgstr ""
":class:`~sqlalchemy.orm.query.Query`\ 는 EXISTS를 자동적으로 사용하는 몇몇 오퍼레이터가 있다. "
"위에서, 명령문은 :meth:`~.RelationshipProperty.Comparator.any`\ 을 사용해서 "
"``User.addresses`` relationship로 표현될 수 있다."

#: ../../orm/tutorial.rst:1563
msgid ""
":meth:`~.RelationshipProperty.Comparator.any` takes criterion as well, to"
" limit the rows matched:"
msgstr ""
":meth:`~.RelationshipProperty.Comparator.any`\ 는 매칭되는 행 갯수를 제한하기 위해 "
"조건을 취하기도 한다:"

#: ../../orm/tutorial.rst:1578
msgid ""
":meth:`~.RelationshipProperty.Comparator.has` is the same operator as "
":meth:`~.RelationshipProperty.Comparator.any` for many-to-one "
"relationships (note the ``~`` operator here too, which means \"NOT\"):"
msgstr ""
":meth:`~.RelationshipProperty.Comparator.has`\ 는"
"다대일 relationship을 위한 :meth:`~.RelationshipProperty.Comparator.any`\ 와 동일하다. "
"(여기에도 ``~`` 연산자가 있다, 이것은 \"NOT\"을 의미한다):"

#: ../../orm/tutorial.rst:1597
msgid "Common Relationship Operators"
msgstr "자주 쓰이는 Relationship 연산자"

#: ../../orm/tutorial.rst:1599
msgid ""
"Here's all the operators which build on relationships - each one is "
"linked to its API documentation which includes full details on usage and "
"behavior:"
msgstr ""
"아래에는 relationship을 기반으로하는 모든 연산자가 있다 -"
"각각은 사용법과 동작에 대한 전체 내용이 있는 API 문서에 연결되어 있다:"

#: ../../orm/tutorial.rst:1603
msgid ""
":meth:`~.RelationshipProperty.Comparator.__eq__` (many-to-one \"equals\" "
"comparison)::"
msgstr ""
":meth:`~.RelationshipProperty.Comparator.__eq__` (다대일 동일 대조)::"

#: ../../orm/tutorial.rst:1607
msgid ""
":meth:`~.RelationshipProperty.Comparator.__ne__` (many-to-one \"not "
"equals\" comparison)::"
msgstr ""
":meth:`~.RelationshipProperty.Comparator.__ne__` (다대일 비동일 대조)::"

#: ../../orm/tutorial.rst:1611
msgid ""
"IS NULL (many-to-one comparison, also uses "
":meth:`~.RelationshipProperty.Comparator.__eq__`)::"
msgstr ""
"IS NULL (다대일 대조, 다음 방식을 사용할 수도 있음 "
":meth:`~.RelationshipProperty.Comparator.__eq__`)::"

#: ../../orm/tutorial.rst:1615
msgid ""
":meth:`~.RelationshipProperty.Comparator.contains` (used for one-to-many "
"collections)::"
msgstr ""
":meth:`~.RelationshipProperty.Comparator.contains` (일대다 컬렉션에 사용됨)::"

#: ../../orm/tutorial.rst:1619
msgid ":meth:`~.RelationshipProperty.Comparator.any` (used for collections)::"
msgstr ""
":meth:`~.RelationshipProperty.Comparator.any` (컬렉션에 사용됨)::"

#: ../../orm/tutorial.rst:1626
msgid ""
":meth:`~.RelationshipProperty.Comparator.has` (used for scalar "
"references)::"
msgstr ""
":meth:`~.RelationshipProperty.Comparator.has` (스칼라 참조에 사용됨)::"

#: ../../orm/tutorial.rst:1630
msgid ":meth:`.Query.with_parent` (used for any relationship)::"
msgstr ""
":meth:`.Query.with_parent` (모든 relationship에 사용됨)::"

#: ../../orm/tutorial.rst:1635
msgid "Eager Loading"
msgstr "Eager 로딩"

#: ../../orm/tutorial.rst:1637
msgid ""
"Recall earlier that we illustrated a :term:`lazy loading` operation, when"
" we accessed the ``User.addresses`` collection of a ``User`` and SQL was "
"emitted.  If you want to reduce the number of queries (dramatically, in "
"many cases), we can apply an :term:`eager load` to the query operation."
"   SQLAlchemy offers three types of eager loading, two of which are "
"automatic, and a third which involves custom criterion.   All three are "
"usually invoked via functions known as :term:`query options` which give "
"additional instructions to the :class:`.Query` on how we would like "
"various attributes to be loaded, via the :meth:`.Query.options` method."
msgstr ""
"이전에 ``User``\ 의 ``User.addresses``\ 컬렉션에 접근하고 SQL이 내보내졌을 때 "
":term:`lazy loading` 작동에 대해서 설명한 것을 기억해보자. "
"만약 (대부분의 경우에, 극적으로) 쿼리의 수를 줄이고 싶다면 "
"쿼리 작동에 :term:`eager load`\ 를 적용시킬 수 있다. "
"SQLAlchemy는 세 가지 타입의 eager loading을 제공하며, 이중 두 가지는 자동이고,"
"하나는 커스텀 조건을 포함하고 있다. 세 가지 모두 :term:`query options`\ 이라 하는 함수를 "
"통해서 호출되고 이 함수는 추가적인 지시사항(다양한 속성을 어떻게 로드할 것인가)을 "
":meth:`.Query.options` 메서드를 통해 :class:`.Query`\ 에 제공한다."

#: ../../orm/tutorial.rst:1647
msgid "Selectin Load"
msgstr "Selectin 로드"

#: ../../orm/tutorial.rst:1649
msgid ""
"In this case we'd like to indicate that ``User.addresses`` should load "
"eagerly. A good choice for loading a set of objects as well as their "
"related collections is the :func:`.orm.selectinload` option, which emits "
"a second SELECT statement that fully loads the collections associated "
"with the results just loaded. The name \"selectin\" originates from the "
"fact that the SELECT statement uses an IN clause in order to locate "
"related rows for multiple objects at once:"
msgstr ""
"``User.addresses``\ 가 단번에 로드되게 지시하고 싶은 경우. "
"객체 집합과 연결된 컬렉션을 같이 로드하기 위한 좋은 선택지는 :func:`.orm.subqueryload` 옵션이다. "
"이 옵션은 로드된 결과와 연관된 컬렉션을 완전히 로드하는 두 번째 SELECT 명령문을 내보낸다. "
"\"selectin\"라는 이름은 SELECET 명령문이 여러 객체에 대한 관련된 행을 한 번에 찾기 위해서 IN 절을 사용한다는 점 때문에 "
"만들어졌다."

#: ../../orm/tutorial.rst:1685
msgid "Joined Load"
msgstr "Joined 로드"

#: ../../orm/tutorial.rst:1687
msgid ""
"The other automatic eager loading function is more well known and is "
"called :func:`.orm.joinedload`.   This style of loading emits a JOIN, by "
"default a LEFT OUTER JOIN, so that the lead object as well as the related"
" object or collection is loaded in one step.   We illustrate loading the "
"same ``addresses`` collection in this way - note that even though the "
"``User.addresses`` collection on ``jack`` is actually populated right "
"now, the query will emit the extra join regardless:"
msgstr ""
"다른 자동 eager loading 함수는 더 잘 알려져있으며 :func:`.orm.joinedload`\ 라고 한다. "
"이 로딩 스타일은 JOIN(기본적으로 LEFT OUTER JOIN)을 내보내고, 관련된 객체나 컬렉션 "
"뿐만 아니라 리드 객체까지 한 번에 로드한다. 우리는 이 방식으로 같은 ``addresses`` 컬렉션을 "
"로드하는 것을 설명할 수 있다. - ``jack``\ 에 있는 ``User.addresses`` 컬렉션이 지금 populated 되었더라도, 쿼리는 "
"상관 없이 추가 join을 내보낼 것이다:"

#: ../../orm/tutorial.rst:1720
msgid ""
"Note that even though the OUTER JOIN resulted in two rows, we still only "
"got one instance of ``User`` back.  This is because :class:`.Query` "
"applies a \"uniquing\" strategy, based on object identity, to the "
"returned entities.  This is specifically so that joined eager loading can"
" be applied without affecting the query results."
msgstr ""
"OUTER JOIN이 두 행을 결과로 가지더라도, 우리는 여전히 "
"하나의 ``User`` 인스턴스만 돌려받는다. 왜냐하면 :class:`.Query`\ 가 객체 아이덴티티에 기반을 둔 \"uniquing\" 전략을 "
"반환된 개체에 적용하고 있기 때문이다. 이것은 특히 join된 eager loading이 쿼리 결과에 "
"영향을 미치지않고 적용될 수 있게 한다."

#: ../../orm/tutorial.rst:1725
msgid ""
"While :func:`.joinedload` has been around for a long time, "
":func:`.selectinload` is a newer form of eager loading.   "
":func:`.selectinload` tends to be more appropriate for loading related "
"collections while :func:`.joinedload` tends to be better suited for many-"
"to-one relationships, due to the fact that only one row is loaded for "
"both the lead and the related object.   Another form of loading, "
":func:`.subqueryload`, also exists, which can be used in place of "
":func:`.selectinload` when making use of composite primary keys on "
"certain backends."
msgstr ""
":func:`.joinedload`\ 이 오랫동안 존재해왔던 반면에 :func:`.subqueryload`\ 새로 등장한 eager loading "
"형태다. :func:`.joinedload`\ 는 리드 객체와 연관된 객체에 대해 하나의 행만 로드된다는 사실 때문에 "
"다대일 relationship에 더 적합한 반면 :func:`.subqueryload`\ 는 연관된 컬렉션을 로드하는 데 더 적합한 경향이 있다. "

msgid "``joinedload()`` is not a replacement for ``join()``"
msgstr ""
"``joinedload()``\ 는 ``join()``\ 를 대체하는 것이 아니다."

#: ../../orm/tutorial.rst:1736
msgid ""
"The join created by :func:`.joinedload` is anonymously aliased such that "
"it **does not affect the query results**.   An :meth:`.Query.order_by` or"
" :meth:`.Query.filter` call **cannot** reference these aliased tables - "
"so-called \"user space\" joins are constructed using :meth:`.Query.join`."
"   The rationale for this is that :func:`.joinedload` is only applied in "
"order to affect how related objects or collections are loaded as an "
"optimizing detail - it can be added or removed with no impact on actual "
"results.   See the section :ref:`zen_of_eager_loading` for a detailed "
"description of how this is used."
msgstr ""
":func:`.joinedload`\ 로 생성된 join은 익명으로 aliased 되어서 "
"**쿼리 결과에 영향을 미치지 않는다**. :meth:`.Query.order_by` 또는 "
":meth:`.Query.filter` 호출은 이 aliased 테이블을 참조하지 **못한다** - "
"소위 \"user space\" join은 :meth:`.Query.join`\ 을 사용해서 생성된다. "
":func:`.joinedload`\ 는 오로지 연관된 객체나 컬렉션이 optimizing detail로서 로드되는 방식에 "
"영향을 주기위해만 적용된다. 실제 결과에 영향을 주지 않고 "
"제거되거나 추가될 수 있다. 사용되는 방식에 대한 자세한 설명은 :ref:`zen_of_eager_loading`\ 를 "
"참고하라."

#: ../../orm/tutorial.rst:1747
msgid "Explicit Join + Eagerload"
msgstr "명시적 Join + Eager 로드"

#: ../../orm/tutorial.rst:1749
msgid ""
"A third style of eager loading is when we are constructing a JOIN "
"explicitly in order to locate the primary rows, and would like to "
"additionally apply the extra table to a related object or collection on "
"the primary object.   This feature is supplied via the "
":func:`.orm.contains_eager` function, and is most typically useful for "
"pre-loading the many-to-one object on a query that needs to filter on "
"that same object.  Below we illustrate loading an ``Address`` row as well"
" as the related ``User`` object, filtering on the ``User`` named \"jack\""
" and using :func:`.orm.contains_eager` to apply the \"user\" columns to "
"the ``Address.user`` attribute:"
msgstr ""
"세 번째 스타일의 eager loading은 primary 행을 찾기 위해 명시적으로 JOIN을 생성할 때와 "
"추가 테이블을 관련된 객체나 primary 객체의 컬렉션에 적용하고 싶을 때 사용한다. "
"이 기능은 :func:`.orm.contains_eager` 함수를 사용해서 제공되며, 일반적으로 동일한 객체에 대한 "
"필터링이 필요한 쿼리의 다대일 객체를 프리로딩 할 때 가장 유용하다. "
"아래에서 우리는 \"jack\" 이름의 ``User``\ 를 필터링하고 "
":func:`.orm.contains_eager`\ 를 사용해서 \"user\" 컬럼을 ``Address.user`` 속성에 적용하면서 "
"``Address`` 행과, 관련된 ``User`` 객체까지 로드하는 것을 설명했다:"

#: ../../orm/tutorial.rst:1784
msgid ""
"For more information on eager loading, including how to configure various"
" forms of loading by default, see the section "
":doc:`/orm/loading_relationships`."
msgstr ""
"다양한 형태의 기본 로딩 설정을 조정하는 방법과 eager loading에 대한 자세한 정보는 "
":doc:`/orm/loading_relationships`\ 를 참고하라."

#: ../../orm/tutorial.rst:1788
msgid "Deleting"
msgstr "삭제"

#: ../../orm/tutorial.rst:1790
msgid ""
"Let's try to delete ``jack`` and see how that goes. We'll mark the object"
" as deleted in the session, then we'll issue a ``count`` query to see "
"that no rows remain:"
msgstr ""
"``jack``\ 을 지우고 어떻게 진행되는지를 보자. 세션에서 객체를 삭제한 것으로 표시하고 "
"남아있는 행이 없는지 확인하기 위해 ``count`` 쿼리를 발행할 것이다:"

#: ../../orm/tutorial.rst:1811
msgid "So far, so good.  How about Jack's ``Address`` objects ?"
msgstr "현재까지는 이상이 없다. Jack의 ``Address`` 객체는 어떨까?"

#: ../../orm/tutorial.rst:1827
msgid ""
"Uh oh, they're still there ! Analyzing the flush SQL, we can see that the"
" ``user_id`` column of each address was set to NULL, but the rows weren't"
" deleted. SQLAlchemy doesn't assume that deletes cascade, you have to "
"tell it to do so."
msgstr ""
"아직까지 남아있다! flush SQL을 분석해보면, 각 address의 ``user_id`` 컬럼이 NULL로 설정되있지만 "
"행이 삭제되지는 않은 것을 볼 수 있다. SQLAlchemy는 cascade를 삭제를 함부로 가정하지 않는다. "
"당신이 직접 그렇게 하도록 명령해야 한다."

#: ../../orm/tutorial.rst:1835
msgid "Configuring delete/delete-orphan Cascade"
msgstr ""
"delete/delete-orphan Cascade 설정하기(Configuring delete/delete-orphan Cascade)"

#: ../../orm/tutorial.rst:1837
msgid ""
"We will configure **cascade** options on the ``User.addresses`` "
"relationship to change the behavior. While SQLAlchemy allows you to add "
"new attributes and relationships to mappings at any point in time, in "
"this case the existing relationship needs to be removed, so we need to "
"tear down the mappings completely and start again - we'll close the "
":class:`.Session`::"
msgstr ""
"동작을 변경하기 위해 ``User.addresses`` relationship에 있는 **cascade** 옵션을 설정할 것이다. "
"SQLAlchemy는 새로운 속성과 relationship을 어느 시점에나 매핑에 추가할 수 있게 "
"해주지만 이 경우에는 이미 존재하는 relationship을 제거해야 하므로 "
"매핑을 완전히 제거하고 새로 시작해야 할 필요가 있다 - 우리는 :class:`.Session`\ 을 닫을 것이다::"

#: ../../orm/tutorial.rst:1847
msgid "and use a new :func:`.declarative_base`:: "
msgstr ""
"그리고 새로운 :func:`.declarative_base`\ 를 사용할 것이다:: "

#: ../../orm/tutorial.rst:1851
msgid ""
"Next we'll declare the ``User`` class, adding in the ``addresses`` "
"relationship including the cascade configuration (we'll leave the "
"constructor out too)::"
msgstr ""
"그 다음 ``User`` 클래스를 선언하고, cascade 설정을 포함한 ``addresses`` relationship을 "
"추가할 것이다 (컨스트럭터는 생략할 것이다)::"

#: ../../orm/tutorial.rst:1869
msgid ""
"Then we recreate ``Address``, noting that in this case we've created the "
"``Address.user`` relationship via the ``User`` class already::"
msgstr ""
"그리고 ``Address``\ 를 다시 생성한다, 이 경우 이미 ``User`` 클래스를 통해서 "
"``Address.user`` relationship을 생성했다는 것을 명심하라::"

#: ../../orm/tutorial.rst:1882
msgid ""
"Now when we load the user ``jack`` (below using :meth:`~.Query.get`, "
"which loads by primary key), removing an address from the corresponding "
"``addresses`` collection will result in that ``Address`` being deleted:"
msgstr ""
"이제 user ``jack``\ 을 로드할 때 (primary key로 로드하는 :meth:`~.Query.get`\ 를 사용했다), "
"``addresses`` 컬렉션에 대응하는 address를 제거하면 "
"``Address``\ 도 제거되는 결과를 얻을 수 있다:"

#: ../../orm/tutorial.rst:1926
msgid ""
"Deleting Jack will delete both Jack and the remaining ``Address`` "
"associated with the user:"
msgstr ""
"Jack을 삭제하면 Jack과 그 user와 연결된 ``Address``\ 도 제거된다:"

msgid "More on Cascades"
msgstr ""
"Cascade에 대한 추가 내용"

#: ../../orm/tutorial.rst:1962
msgid ""
"Further detail on configuration of cascades is at "
":ref:`unitofwork_cascades`. The cascade functionality can also integrate "
"smoothly with the ``ON DELETE CASCADE`` functionality of the relational "
"database. See :ref:`passive_deletes` for details."
msgstr ""
"cascade 설정에 대한 세부 사항은 :ref:`unitofwork_cascades`\ 에 설명되어 "
"있다. cascade 기능은 관계형 데이터베이스의 ``ON DELETE CASCADE`` 기능과 "
"원활하게 통합될 수도 있다. 자세한 내용은 :ref:`passive_deletes`\ 를 "
"참고하라"

#: ../../orm/tutorial.rst:1970
msgid "Building a Many To Many Relationship "
msgstr "다대다 Relationship 만들기(Building a Many to Many Relationship)"

#: ../../orm/tutorial.rst:1972
msgid ""
"We're moving into the bonus round here, but lets show off a many-to-many "
"relationship. We'll sneak in some other features too, just to take a "
"tour. We'll make our application a blog application, where users can "
"write ``BlogPost`` items, which have ``Keyword`` items associated with "
"them."
msgstr ""
"여기서 보너스 라운드로 이동하기 전에 다대다 관계를 보여줄 것이다. "
"물론 다른 기능들도 둘러볼 것이다. "
"우리는 사용자가 ``BlogPost``\ 와 연관된 ``Keyword`` 항목이 있는 "
"``BlogPost``\ 을 작성하는 블로그 어플리케이션을 만들 것이다. "

#: ../../orm/tutorial.rst:1977
msgid ""
"For a plain many-to-many, we need to create an un-mapped :class:`.Table` "
"construct to serve as the association table.  This looks like the "
"following::"
msgstr ""
"일반적인 다대다의 경우, 매핑되지 않은 :class:`.Table` 구조를 생성해서 "
"연결 테이블로 활용해야 한다. 방식은 아래와 같다::"

#: ../../orm/tutorial.rst:1987
msgid ""
"Above, we can see declaring a :class:`.Table` directly is a little "
"different than declaring a mapped class.  :class:`.Table` is a "
"constructor function, so each individual :class:`.Column` argument is "
"separated by a comma.  The :class:`.Column` object is also given its name"
" explicitly, rather than it being taken from an assigned attribute name."
msgstr ""
"위에서 우리는 :class:`.Table`\ 를 직접 선언하는 것이 매핑된 클래스를 생성하는 것과 조금 다르다는 "
"사실을 볼 수 있다. :class:`.Table`\ 는 constructor 함수로, 개별 :class:`.Column` 인수는 "
"콤마로 나뉘어져 있다. :class:`.Column` 객체는 할당된 속성 이름에서 가져오는 것이 아니라 명시적으로 이름을 "
"제공받는다."


#: ../../orm/tutorial.rst:1993
msgid ""
"Next we define ``BlogPost`` and ``Keyword``, using complementary "
":func:`.relationship` constructs, each referring to the ``post_keywords``"
" table as an association table::"
msgstr ""
"그 다음 우리는 상호보완적인 :func:`.relationship` 구조를 사용해 ``BlogPost``\ 와 ``Keyword``\ 를 정의했고 "
"각각은 ``post_keywords``\ 를 연결 테이블로 참조한다::"

#: ../../orm/tutorial.rst:2033
msgid ""
"The above class declarations illustrate explicit ``__init__()`` methods. "
"Remember, when using Declarative, it's optional!"
msgstr ""
"위의 클래스 선언에서는 명시적인 ``__init__()`` 메서드를 보여주고 있다. "
"Declarative를 사용할 때 이것은 선택적인 부분임을 명심하라!"

#: ../../orm/tutorial.rst:2036
msgid ""
"Above, the many-to-many relationship is ``BlogPost.keywords``. The "
"defining feature of a many-to-many relationship is the ``secondary`` "
"keyword argument which references a :class:`~sqlalchemy.schema.Table` "
"object representing the association table. This table only contains "
"columns which reference the two sides of the relationship; if it has "
"*any* other columns, such as its own primary key, or foreign keys to "
"other tables, SQLAlchemy requires a different usage pattern called the "
"\"association object\", described at :ref:`association_pattern`."
msgstr ""
"위에서, 다대다 relationship은 ``BlogPost.keywords``\ 다. 다대다 relationship의 "
"기능을 정의하는 것은 ``secondary`` 키워드 인수이며 이 인수는 연결 테이블을 나타내는 "
":class:`~sqlalchemy.schema.Table` 객체를 참조한다. "
"이 테이블은 relationship의 양쪽을 참조하는 컬럼만 포함한다; 만약 자신의 primary key나 다른 테이블에 대한 foreign key "
"같은 다른 컬럼을 포함하고 있다면 SQLAlchemy는 \"association object\"라고 하는 다른 사용 패턴을 요구한다. "
"이에 관해서는 :ref:`association_pattern`\ 에서 설명하고 있다. "


#: ../../orm/tutorial.rst:2045
msgid ""
"We would also like our ``BlogPost`` class to have an ``author`` field. We"
" will add this as another bidirectional relationship, except one issue "
"we'll have is that a single user might have lots of blog posts. When we "
"access ``User.posts``, we'd like to be able to filter results further so "
"as not to load the entire collection. For this we use a setting accepted "
"by :func:`~sqlalchemy.orm.relationship` called ``lazy='dynamic'``, which "
"configures an alternate **loader strategy** on the attribute:"
msgstr ""
"또한 우리는 ``BlogPost`` 클래스가 ``author`` 필드를 갖기를 원한다. "
"우리는 한 사용자가 많은 블로그 포스트를 작성할 수 있다는 것만 제외하면 이것을 다른 양방향 relationship으로 추가할 것이다."
"우리가 ``User.posts``\ 에 접근할 때, 전체 컬렉션을 다 로드하지 않도록 결과를 더 필터링할 수 있으면 "
"좋을 것이다. 이것을 위해서 우리는 :func:`~sqlalchemy.orm.relationship`\ 의해 용인되는 "
"``lazy='dynamic'``\ 라고 불리는 세팅을 사용할 것이다. 이 세팅은 속성의 대체 **loader strategy**\ 를"
"구성한다:"
#: ../../orm/tutorial.rst:2058
msgid "Create new tables:"
msgstr "새로운 테이블을 생성한다:"

#: ../../orm/tutorial.rst:2092
msgid ""
"Usage is not too different from what we've been doing.  Let's give Wendy "
"some blog posts:"
msgstr ""
"사용법은 해왔던 것에 비해서 크게 다르지 않다. "
"Wendy에 블로그 포스트 몇 개를 추가하자:"

#: ../../orm/tutorial.rst:2110
msgid ""
"We're storing keywords uniquely in the database, but we know that we "
"don't have any yet, so we can just create them:"
msgstr ""
"우리는 데이터베이스에서 키워드를 유니크하게 저장할 것이다, "
"하지만 저장된 키워드가 아직 없기 때문에 몇 개를 생성했다:"

#: ../../orm/tutorial.rst:2118
msgid ""
"We can now look up all blog posts with the keyword 'firstpost'. We'll use"
" the ``any`` operator to locate \"blog posts where any of its keywords "
"has the keyword string 'firstpost'\":"
msgstr ""
"이제 `firstpost` 키워드를 가진 모든 블로그 포스트를 찾을 수 있다. "
"우리는 ``any`` 오퍼레이터를 사용해서 키워드 문자열로 'fisrtpost'를 포함한 블로그 포스트를 "
"찾을 수 있다:"

#: ../../orm/tutorial.rst:2148
msgid ""
"If we want to look up posts owned by the user ``wendy``, we can tell the "
"query to narrow down to that ``User`` object as a parent:"
msgstr ""
"만약 user ``wendy``\ 가 소유하고 있는 포스트를 찾고 싶으면, 해당 ``User`` 객체를 부모로 "
"쿼리를 좁힐 수 있다:"

#: ../../orm/tutorial.rst:2170
msgid ""
"Or we can use Wendy's own ``posts`` relationship, which is a \"dynamic\" "
"relationship, to query straight from there:"
msgstr "또는 \"dynamic\" relationship인 Wendy 소유의 ``posts`` relationship을 사용해 거기서 바로 쿼리할 수 있다:"

#: ../../orm/tutorial.rst:2192
msgid "Further Reference"
msgstr "더 읽어보기"

#: ../../orm/tutorial.rst:2194
msgid "Query Reference: :ref:`query_api_toplevel`"
msgstr "Query Reference: :ref:`query_api_toplevel`"

#: ../../orm/tutorial.rst:2196
msgid "Mapper Reference: :ref:`mapper_config_toplevel`"
msgstr "Mapper Reference: :ref:`mapper_config_toplevel`"

#: ../../orm/tutorial.rst:2198
msgid "Relationship Reference: :ref:`relationship_config_toplevel`"
msgstr "Relationship Reference: :ref:`relationship_config_toplevel`"

#: ../../orm/tutorial.rst:2200
msgid "Session Reference: :doc:`/orm/session`"
msgstr "Session Reference: :doc:`/orm/session`"
