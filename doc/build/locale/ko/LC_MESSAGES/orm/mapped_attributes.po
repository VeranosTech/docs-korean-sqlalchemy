# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../orm/mapped_attributes.rst:4
msgid "Changing Attribute Behavior"
msgstr "속성 동작 변경"

#: ../../orm/mapped_attributes.rst:9
msgid "Simple Validators"
msgstr "간단한 유효성 검사기들(validators)"

#: ../../orm/mapped_attributes.rst:11
msgid ""
"A quick way to add a \"validation\" routine to an attribute is to use the"
" :func:`~sqlalchemy.orm.validates` decorator. An attribute validator can "
"raise an exception, halting the process of mutating the attribute's "
"value, or can change the given value into something different. "
"Validators, like all attribute extensions, are only called by normal "
"userland code; they are not issued when the ORM is populating the "
"object::"
msgstr ""
"가장 빠르게 \"유효성 검증(validation)\" 루틴을 속성에 추가하는 방법은 "
":func:`~sqlalchemy.orm.validates`\ 데코레이터를 사용하는 것이다."
"속성 유효성 검사기(validators)는 예외를 발생시키거나, 속성의 값 변경 과정을 중단시키고, "
"주어진 값을 다른 값으로 변경하는 작업을 할 수 있다."
"모든 속성 확장(extension) 들과 같이 유효성 검사기는 일반적인 사용자공간(userland) 코드에서만"
"호출될 수 있다. 그들은 ORM 객체를 채워질때 아무런 동작을 하지 않는다."

#: ../../orm/mapped_attributes.rst:31
msgid ""
"- validators are no longer triggered within the flush process when the "
"newly fetched values for primary key columns as well as some python- or "
"server-side defaults are fetched. Prior to 1.0, validators may be "
"triggered in those cases as well."
msgstr ""
"- 파이썬 혹은 서버-사이드 기본값들(defaults) 뿐만 아니라 프라이머리 키 컬럼(primary key column) "
"에 대해 새로 패치 된 값을 가져올때 플러시 프로세스 내에서 더 이상 유효성 검사기가 트리거 되지 않는다. "
"1.0 버젼 이전에서는 유효성 검사기가 트리거 된다."

#: ../../orm/mapped_attributes.rst:37
msgid ""
"Validators also receive collection append events, when items are added to"
" a collection::"
msgstr ""
"또한 유효성 검사기들은 컬렉션(collection)에 아이템이 추가되었을때 "
"컬렉션 추가 이벤트를 받다."

#: ../../orm/mapped_attributes.rst:53
msgid ""
"The validation function by default does not get emitted for collection "
"remove events, as the typical expectation is that a value being discarded"
" doesn't require validation.  However, :func:`.validates` supports "
"reception of these events by specifying ``include_removes=True`` to the "
"decorator.  When this flag is set, the validation function must receive "
"an additional boolean argument which if ``True`` indicates that the "
"operation is a removal::"
msgstr ""
"일반적으로 폐기될 값에 대해 유효성 검사가 필요하지 않기 때문에 유효성 검사기 함수는"
" 컬랙션 제거 이벤트를 방출하지 않다. 그러나 :func:`.validates`\ 함수에 "
"``include_removes=True``\ 를 지정함으로서 이러한 이벤트를 수신 받을 수 있다. "
"이 값(flag)이 설정되면, 유효성 검사기 함수 반드시 추가적인 부울 인수(boolean argument) "
"받아야 합니다. 이것은 ``if True`` 일때 제거 연산임을 나타낸다."

#: ../../orm/mapped_attributes.rst:76
msgid ""
"The case where mutually dependent validators are linked via a backref can"
" also be tailored, using the ``include_backrefs=False`` option; this "
"option, when set to ``False``, prevents a validation function from "
"emitting if the event occurs as a result of a backref::"
msgstr ""
"상호 종속적인 유효성 검사기가 역참조(backref)로 연결된 경우에는 ``include_backrefs=False``\ "
"옵션을 사용하여 각각 유효성 검사기들을 맞춤 설정할 수 있다. 이 옵션을 ``False``\ 설정해두면 "
"유효성 검사 함수가 역참조(backref)의 결과 이벤트들이 생기는 것을 방출하지 않게 한다::"

#: ../../orm/mapped_attributes.rst:93
msgid ""
"Above, if we were to assign to ``Address.user`` as in ``some_address.user"
" = some_user``, the ``validate_address()`` function would *not* be "
"emitted, even though an append occurs to ``some_user.addresses`` - the "
"event is caused by a backref."
msgstr ""
"위의 예제에서, 만약 우리가 ``Address.user``\ 을 ``some_address.user = some_user``\ 처럼 할당한다면 "
"``validate_address()``\ 함수는 이벤트를 방출 하지 **않는다.** 만약 ``some_user.addresses``\ 에 추가 이벤트가"
"발생하더라도 그것은 역참조(backref)에 의해 발생된 것이다."

#: ../../orm/mapped_attributes.rst:97
msgid ""
"Note that the :func:`~.validates` decorator is a convenience function "
"built on top of attribute events.   An application that requires more "
"control over configuration of attribute change behavior can make use of "
"this system, described at :class:`~.AttributeEvents`."
msgstr ""
":func:`~.validates`\ 데코레이터는 속성 이벤트들(attribute events)의 최상위에 만들어진 편리한 함수이다."
":class:`~.AttributeEvents`\ 에 설명된 시스템을 참조하여 속성 변화 동작(attribute change behavior)의"
"구성을 보다 더 많이 제어가 요구되는 어플리케이션을 만들 수 있다. "

#: of sqlalchemy.orm.validates:1
msgid "Decorate a method as a 'validator' for one or more named properties."
msgstr "하나 이상의 명명된 프로퍼티(named properites)에 대한 메서드를 유효성 검사기로 데코레이트 한다."

#: of sqlalchemy.orm.validates:3
msgid ""
"Designates a method as a validator, a method which receives the name of "
"the attribute as well as a value to be assigned, or in the case of a "
"collection, the value to be added to the collection. The function can "
"then raise validation exceptions to halt the process from continuing "
"(where Python's built-in ``ValueError`` and ``AssertionError`` exceptions"
" are reasonable choices), or can modify or replace the value before "
"proceeding. The function should otherwise return the given value."
msgstr ""
"유효성 검사기로 메서드를 만든다. 이 메서드는 값이 할당될 속성의 이름을 받거나, "
"컬랙션에 추가될 값을 받는다. 이 함수는 유효성 검사 예외(validation exception, "
"파이썬의 빌트-인 ``ValueError``\ 나 ``AssertionError``\ 예외가 합리적인 선택이다)"
"을 발생시켜 진행중인 과정을 중지시키거나, 현재 과정 전 값으로 변경시킬 수 있다. "

#: of sqlalchemy.orm.validates:12
msgid ""
"Note that a validator for a collection **cannot** issue a load of that "
"collection within the validation routine - this usage raises an assertion"
" to avoid recursion overflows.  This is a reentrant condition which is "
"not supported."
msgstr ""
"컬랙션에 대한 유효성 검사기는 유효성 검증 루틴 내에서 해당 컬랙션의 로드를 **발행할 수 없다.** "
"이러한 사용방식은 재귀 오버플로우(recursion overflows)를 발생시킬 수 있기에 예외를 발생시킨다."

#: of sqlalchemy.orm.synonym sqlalchemy.orm.validates
msgid "Parameters"
msgstr "파라미터들"

#: of sqlalchemy.orm.validates:17
msgid "list of attribute names to be validated."
msgstr ""

#: of sqlalchemy.orm.validates:18
msgid ""
"if True, \"remove\" events will be sent as well - the validation function"
" must accept an additional argument \"is_remove\" which will be a "
"boolean.  .. versionadded:: 0.7.7"
msgstr ""

#: of sqlalchemy.orm.validates:18
msgid ""
"if True, \"remove\" events will be sent as well - the validation function"
" must accept an additional argument \"is_remove\" which will be a "
"boolean."
msgstr ""

#: of sqlalchemy.orm.validates:23
msgid ""
"defaults to ``True``; if ``False``, the validation function will not emit"
" if the originator is an attribute event related via a backref.  This can"
" be used for bi-directional :func:`.validates` usage where only one "
"validator should emit per attribute operation.  .. versionadded:: 0.9.0"
msgstr ""

#: of sqlalchemy.orm.validates:23
msgid ""
"defaults to ``True``; if ``False``, the validation function will not emit"
" if the originator is an attribute event related via a backref.  This can"
" be used for bi-directional :func:`.validates` usage where only one "
"validator should emit per attribute operation."
msgstr ""

#: of sqlalchemy.orm.validates:33
msgid ":ref:`simple_validators` - usage examples for :func:`.validates`"
msgstr ":ref:`simple_validators` - :func:`.validates`\ 함수 사용 예제"

#: ../../orm/mapped_attributes.rst:107
msgid "Using Descriptors and Hybrids"
msgstr "기술자(Descriptors) 와 하이브리드 사용하기"

#: ../../orm/mapped_attributes.rst:109
msgid ""
"A more comprehensive way to produce modified behavior for an attribute is"
" to use :term:`descriptors`.  These are commonly used in Python using the"
" ``property()`` function. The standard SQLAlchemy technique for "
"descriptors is to create a plain descriptor, and to have it read/write "
"from a mapped attribute with a different name. Below we illustrate this "
"using Python 2.6-style properties::"
msgstr ""
"속성에 대해 수정된 동작을 생성하는 것 보다 포괄적인 방법은 :term:`descriptors`\ 를"
" 사용하는 것이다. "
"이것들은 파이썬에서 ``property()``\ 함수를 사용하여 사용됩니다. 설명자를 위한 표준 SQLAlechmy"
" 기술은 일반 설명자를 작성하고 맵핑 된 속성에서 다른 이름으로 읽고 쓰도록하는 것이다. "
"아래 예제에서 파이썬 2.6-스타일 프로퍼티를 보여준다."

#: ../../orm/mapped_attributes.rst:134
msgid ""
"The approach above will work, but there's more we can add. While our "
"``EmailAddress`` object will shuttle the value through the ``email`` "
"descriptor and into the ``_email`` mapped attribute, the class level "
"``EmailAddress.email`` attribute does not have the usual expression "
"semantics usable with :class:`.Query`. To provide these, we instead use "
"the :mod:`~sqlalchemy.ext.hybrid` extension as follows::"
msgstr ""
"위의 예제는 잘 잘동하지만 우리가 더 추가할 수 있는 부분이 있다. "
"값을 이동 시키지만 클래스 레벨 ``EmailAddress.email``\ 속성은 :class:`.Query`\ 와 "
"사용할 수 있는 일반적인 표현식 의미를 갖지 않는다. "
"이를 제공하기 위해 우리는 아래와 같이 :mod:`~sqlalchemy.ext.hybrid`\ 확장(extension)을 사용한다."

#: ../../orm/mapped_attributes.rst:158
msgid ""
"The ``.email`` attribute, in addition to providing getter/setter behavior"
" when we have an instance of ``EmailAddress``, also provides a SQL "
"expression when used at the class level, that is, from the "
"``EmailAddress`` class directly:"
msgstr ""
"이 ``.email``\ 속성은 ``EmailAddress``\ 인스턴스에서 접근자/수정자(getter/setter) 동작을 지원하더라도 "
"``EmaillAddress``\ 클래스 레벨에서 직접적으로 쿼리 표현식을 제공한다."

#: ../../orm/mapped_attributes.rst:183
msgid ""
"The :class:`~.hybrid_property` also allows us to change the behavior of "
"the attribute, including defining separate behaviors when the attribute "
"is accessed at the instance level versus at the class/expression level, "
"using the :meth:`.hybrid_property.expression` modifier. Such as, if we "
"wanted to add a host name automatically, we might define two sets of "
"string manipulation logic::"
msgstr ""
":class:`~.hybrid_property`\ 는 인스턴스 레벨에서 동작하거나 클래스/표현식 레벨"
"에서 속성에 접근했을 때 서로 다른 동작을 할 수 있도록 변화를 줄 수 있다."
"이를 위해서 :meth:`.hybrid_property.expression`\ 을 사용한다."
"예를 들어, 만약 우리가 다양한 호스트 이름을 자동적으로 추가하길 원한다면 우리는 "
"두 가지의 문자열 조작 로직을 정의할 수 있다::"

#: ../../orm/mapped_attributes.rst:218
msgid ""
"Above, accessing the ``email`` property of an instance of "
"``EmailAddress`` will return the value of the ``_email`` attribute, "
"removing or adding the hostname ``@example.com`` from the value. When we "
"query against the ``email`` attribute, a SQL function is rendered which "
"produces the same effect:"
msgstr ""
"위의 예제에서 ``EmailAddress``\ 인스턴스의 ``email`` 특성(property)를 접근 하는 것은 "
"호스트 이름 ``@example.com``\ 값이 추가되거나 제거된 ``_email``\ 속성(attribute)의 값을 반환한다. "
"또한 ``email`` 속성에 대해 쿼리한다면, 같은 효과를 내는 SQL 함수가 렌더링 된다."

#: ../../orm/mapped_attributes.rst:232
msgid "Read more about Hybrids at :ref:`hybrids_toplevel`."
msgstr "하이브리드에 대해 더 알아보려면 :ref:`hybrids_toplevel`\ 을 참조."

#: ../../orm/mapped_attributes.rst:237
msgid "Synonyms"
msgstr "동의어들(Synonyms)"

#: ../../orm/mapped_attributes.rst:239
msgid ""
"Synonyms are a mapper-level construct that allow any attribute on a class"
" to \"mirror\" another attribute that is mapped."
msgstr ""
"동의어들은 클래스의 모든 속성을 매핑된 다른 속성과 \"미러링\" 할 수 있게 해주는 매퍼 수준 구조이다::"

#: ../../orm/mapped_attributes.rst:242
msgid ""
"In the most basic sense, the synonym is an easy way to make a certain "
"attribute available by an additional name::"
msgstr ""
"대부분의 시나리오에서, 동의어는 추가 이름으로 특정 속성을 사용 가능하게 해주는 가장 쉬운 방법이다::"

#: ../../orm/mapped_attributes.rst:253
msgid ""
"The above class ``MyClass`` has two attributes, ``.job_status`` and "
"``.status`` that will behave as one attribute, both at the expression "
"level::"
msgstr ""
"위의 ``MyClass``\ 클래스는 ``.job_status``\ 와 ``.status``\ 라는 두 가지 속성을"
"가지고 있다. 이것들은 표현식 레벨에서 하나의 속성처럼 작동할 것이다::"

#: ../../orm/mapped_attributes.rst:263
msgid "and at the instance level::"
msgstr "그리고 인스턴스 레벨에서도::"

#: ../../orm/mapped_attributes.rst:273
msgid ""
"The :func:`.synonym` can be used for any kind of mapped attribute that "
"subclasses :class:`.MapperProperty`, including mapped columns and "
"relationships, as well as synonyms themselves."
msgstr ""
":func:`.synonym`\ 함수는 :class:`.MapperProperty`\ 의 서브클래스인 모든 매핑된 속성들에 사용될 수 있다."
"이것은 매핑된 컬럼들이나 관계, 동의어 자체를 포함한다."

#: ../../orm/mapped_attributes.rst:277
msgid ""
"Beyond a simple mirror, :func:`.synonym` can also be made to reference a "
"user-defined :term:`descriptor`.  We can supply our ``status`` synonym "
"with a ``@property``::"
msgstr ""
"단순한 미러링 이외에도 :func:`.synonym`\ 함수는 사용자가 정의한 :term:`descriptor`\ 에도 참조를 만들 수 있다."
"우리는 ``status``\ 동의어를 ``@property``\ 를 통해 적용할 수 있다::"

#: ../../orm/mapped_attributes.rst:293
msgid ""
"When using Declarative, the above pattern can be expressed more "
"succinctly using the :func:`.synonym_for` decorator::"
msgstr ""
"선언적 시스템을 사용한다면, 위의 패턴은 :func:`.synonym_for`\ 데코레이터를 사용하여 "
"보다 간결하게 표현될 수 있다."

#: ../../orm/mapped_attributes.rst:309
msgid ""
"While the :func:`.synonym` is useful for simple mirroring, the use case "
"of augmenting attribute behavior with descriptors is better handled in "
"modern usage using the :ref:`hybrid attribute <mapper_hybrids>` feature, "
"which is more oriented towards Python descriptors.   Technically, a "
":func:`.synonym` can do everything that a :class:`.hybrid_property` can "
"do, as it also supports injection of custom SQL capabilities, but the "
"hybrid is more straightforward to use in more complex situations."
msgstr ""
"간단한 미러링에는 :func:`.synonym`\ 함수가 쓸모있지만 설명자(descriptor)로 "
"속성의 행동을 보완하는 케이스에선 python 설명자(descriptor)에서 나온 :ref:`hybrid attribute <mapper_hybrids>`\ 최근 기능"
"을 사용하는 것이 더 좋다."
"기술적으론 :func:`.synonym`\ :class:`.hybrid_property`\ 가 할수있는 것들(커스텀 SQL 호환성 까지 지원)을 모두 할 수 있지만"
"하이드리드는 복잡한 상황에서 좀 더 직관적으로 작동한다."

#: of sqlalchemy.orm.synonym:1
msgid ""
"Denote an attribute name as a synonym to a mapped property, in that the "
"attribute will mirror the value and expression behavior of another "
"attribute."
msgstr ""
"속성 이름이 다른 속성의 값 및 표현식 동작을 미러링한다는"
"점에서 매핑 된 속성의 동의어로 속성 이름을 나타냅니다."

#: of sqlalchemy.orm.synonym:5
msgid "e.g.::"
msgstr "예::"

#: of sqlalchemy.orm.synonym:16
msgid ""
"the name of the existing mapped property.  This can refer to the string "
"name ORM-mapped attribute configured on the class, including column-bound"
" attributes and relationships."
msgstr ""
"기존의 매핑된 속성 이름. 이것은 열-바인딩(column-bound) 속성 및 관계들을 포함하여 "
"클래스에 구성된 ORM-매핑된 속성의 문자열 이름을 참조할 수 있다."

#: of sqlalchemy.orm.synonym:21
msgid ""
"a Python :term:`descriptor` that will be used as a getter (and "
"potentially a setter) when this attribute is accessed at the instance "
"level."
msgstr ""
"속성이 인스턴스 레벨에서 접근될 경우, 파이썬 :term:`descriptor`\ 은 접근자/설정자(getter/setter)로 사용될 수 있다."

#: of sqlalchemy.orm.synonym:25
#, python-format
msgid ""
"**For classical mappings and mappings against an existing Table object "
"only**.  if ``True``, the :func:`.synonym` construct will locate the "
":class:`.Column` object upon the mapped table that would normally be "
"associated with the attribute name of this synonym, and produce a new "
":class:`.ColumnProperty` that instead maps this :class:`.Column` to the "
"alternate name given as the \"name\" argument of the synonym; in this "
"way, the usual step of redefining the mapping of the :class:`.Column` to "
"be under a different name is unnecessary. This is usually intended to be "
"used when a :class:`.Column` is to be replaced with an attribute that "
"also uses a descriptor, that is, in conjunction with the "
":paramref:`.synonym.descriptor` parameter::    my_table = Table(       "
"\"my_table\", metadata,       Column('id', Integer, primary_key=True),"
"       Column('job_status', String(50))   )    class MyClass(object):"
"       @property       def _job_status_descriptor(self):           return"
" \"Status: %s\" % self._job_status     mapper(       MyClass, my_table, "
"properties={           \"job_status\": synonym(               "
"\"_job_status\", map_column=True,               "
"descriptor=MyClass._job_status_descriptor)       }   )  Above, the "
"attribute named ``_job_status`` is automatically mapped to the "
"``job_status`` column::    >>> j1 = MyClass()   >>> j1._job_status = "
"\"employed\"   >>> j1.job_status   Status: employed  When using "
"Declarative, in order to provide a descriptor in conjunction with a "
"synonym, use the :func:`sqlalchemy.ext.declarative.synonym_for` helper.  "
"However, note that the :ref:`hybrid properties <mapper_hybrids>` feature "
"should usually be preferred, particularly when redefining attribute "
"behavior."
msgstr ""

#: of sqlalchemy.orm.synonym:25
msgid ""
"**For classical mappings and mappings against an existing Table object "
"only**.  if ``True``, the :func:`.synonym` construct will locate the "
":class:`.Column` object upon the mapped table that would normally be "
"associated with the attribute name of this synonym, and produce a new "
":class:`.ColumnProperty` that instead maps this :class:`.Column` to the "
"alternate name given as the \"name\" argument of the synonym; in this "
"way, the usual step of redefining the mapping of the :class:`.Column` to "
"be under a different name is unnecessary. This is usually intended to be "
"used when a :class:`.Column` is to be replaced with an attribute that "
"also uses a descriptor, that is, in conjunction with the "
":paramref:`.synonym.descriptor` parameter::"
msgstr ""
"**고전적 매핑과 이미 존재하는 테이블 객체 매핑만 해당한다**. :func:`.synonym`\ 구조는"
"일반적으로 동의어의 속성 이름과 연관된 매핑 테이블에서 :class:`.Column`\ 의 위치를 찾아내고, "
"이 함수의 \"name\" 인자로 주어진 이름과 :class:`.Column`\ 클래스를 매핑시키는 대신 "
"새로운 :class:`.ColumnProperty`\ 클래스를 생성한다. "
"이러한 방법을 통해서 일반적인 :class:`.Column`\ 매핑 재정의 단계가(다른 이름으로 변경) 필요없게 된다."
"일반적으로, :class:`.Column`\ 클래스가 설명자를(descriptor) 을 사용하는 속성으로 대체될때 "
"사용되기 위해 의도 되었다. 즉 :paramref:`.synonym.descriptor`\ 파라미터와 함께 사용될 때를 의미한다"

#: of sqlalchemy.orm.synonym:58
msgid ""
"Above, the attribute named ``_job_status`` is automatically mapped to the"
" ``job_status`` column::"
msgstr ""
"위의 코드에서, 속성 이름 ``_job_status``\ 은 자동적으로 ``job_status`` 컬럼에 매핑된다::"

#: of sqlalchemy.orm.synonym:66
msgid ""
"When using Declarative, in order to provide a descriptor in conjunction "
"with a synonym, use the :func:`sqlalchemy.ext.declarative.synonym_for` "
"helper.  However, note that the :ref:`hybrid properties <mapper_hybrids>`"
" feature should usually be preferred, particularly when redefining "
"attribute behavior."
msgstr ""
"선언적 시스템(Declarative)을 사용할때 동의어와 함깨 설명자(descriptor)를 제공하기위해선 "
":func:`sqlalchemy.ext.declarative.synonym_for`\ 함수를 사용한다."
"그러나 속성 동장(attribute behavior)을 재정의할땐 주로 :ref:`hybrid properties <mapper_hybrids>`\ "
"기능을 사용하는 것을 추천한다"

#: of sqlalchemy.orm.synonym:73
msgid ""
"Optional data dictionary which will be populated into the "
":attr:`.InspectionAttr.info` attribute of this object.  .. versionadded::"
" 1.0.0"
msgstr ""
"이 객체의 :attr:`.InspectionAttr.info`\ 속성으로 채워질 선택적 데이터 사전(Optional data dictionary) 이다."
".. versionadded:: 1.0.0"

#: of sqlalchemy.orm.synonym:73
msgid ""
"Optional data dictionary which will be populated into the "
":attr:`.InspectionAttr.info` attribute of this object."
msgstr ""
"이 객체의 :attr:`.InspectionAttr.info`\ 속성으로 채워질 선택적 데이터 사전(Optional data dictionary) 이다."

#: of sqlalchemy.orm.synonym:78
msgid ""
"A subclass of :class:`.PropComparator` that will provide custom "
"comparison behavior at the SQL expression level.  .. note::    For the "
"use case of providing an attribute which redefines both   Python-level "
"and SQL-expression level behavior of an attribute,   please refer to the "
"Hybrid attribute introduced at   :ref:`mapper_hybrids` for a more "
"effective technique."
msgstr ""
":class:`.PropComparator`\ 클래스의 서브클래스는 "
"쿼리 표현식 수준에서 사용자 정의 비교 동작을 제공할 것이다. "
" .. note:: 파이썬 레벨과 SQL-표현식 레벨 모두 속성 동작을 재정의 하는 속성을 제공하는 상황에선"
"좀 더 효율적인 기능인 :ref:`mapper_hybrids`\ 에 소개된 하이브리드 속성을 참조한다. "

#: of sqlalchemy.orm.synonym:78
msgid ""
"A subclass of :class:`.PropComparator` that will provide custom "
"comparison behavior at the SQL expression level."
msgstr ""
":class:`.PropComparator`\ 클래스의 서브클래스는 "
"쿼리 표현식 수준에서 사용자 정의 비교 동작을 제공할 것이다."

#: of sqlalchemy.orm.synonym:84
msgid ""
"For the use case of providing an attribute which redefines both Python-"
"level and SQL-expression level behavior of an attribute, please refer to "
"the Hybrid attribute introduced at :ref:`mapper_hybrids` for a more "
"effective technique."
msgstr ""
"파이썬 수준과 SQL 표현 수준에서 속성의 동작을 재정의하는 속성을 제공하는 경우에는"
"보다 효과적인 기술을 위해 :ref:`mapper_hybrids`\ 에서 소개 한 하이브리드 속성을 참조 ."

#: of sqlalchemy.orm.synonym:91
msgid ":ref:`synonyms` - Overview of synonyms"
msgstr ":ref`synonyms` - 동이어(synonyms)의 개요"

#: of sqlalchemy.orm.synonym:93
msgid ":func:`.synonym_for` - a helper oriented towards Declarative"
msgstr ":func:`.synonym_for` - 선언적 시스템(Declarative) 지향 도우미"

#: of sqlalchemy.orm.synonym:95
msgid ""
":ref:`mapper_hybrids` - The Hybrid Attribute extension provides an "
"updated approach to augmenting attribute behavior more flexibly than can "
"be achieved with synonyms."
msgstr ""
":ref:`mapper_hybrids` - 하이브리드 속성 확장(extension)은 동의어를 통해 달성할 수 있는 "
"것 보다 더 유연하게 특성 동작을 보강하는 업데이트된 접근방식을 제공한다."

#: ../../orm/mapped_attributes.rst:322
msgid "Operator Customization"
msgstr "사용자 정의 연산자(Operator Customization)"

#: ../../orm/mapped_attributes.rst:324
msgid ""
"The \"operators\" used by the SQLAlchemy ORM and Core expression language"
" are fully customizable.  For example, the comparison expression "
"``User.name == 'ed'`` makes usage of an operator built into Python itself"
" called ``operator.eq`` - the actual SQL construct which SQLAlchemy "
"associates with such an operator can be modified.  New operations can be "
"associated with column expressions as well.   The operators which take "
"place for column expressions are most directly redefined at the type "
"level -  see the section :ref:`types_operators` for a description."
msgstr ""
" SQLAlchemy ORM 과 핵심 표현식 언어(Core expression language)에서 사용되는 \"연산자(operator)\"\ "
"는 완전히 사용자 정의 할 수 있다. 예를 들어, 비교 표현식 ``User.name == 'ed'``\ 은 "
"파이썬 자체 ``operator.eq`` 연산자를 사용한다. "
"SQLAlchemy가 이러한 연산자와 연관시키는 실제 SQL 구문을 변경할 수 있다. 새로운 연산들은 컬럼 표현식들과 연관되어질 수 있다. "
"컬럼 표현식에서 사용되는 연산들은 대부분 타입 수준(type level)에서 대부분 직접적으로 재정의 된다. "
"좀 더 자세한 정보는 :ref:`types_operators`\ 절을 참조."

#: ../../orm/mapped_attributes.rst:334
msgid ""
"ORM level functions like :func:`.column_property`, :func:`.relationship`,"
" and :func:`.composite` also provide for operator redefinition at the ORM"
" level, by passing a :class:`.PropComparator` subclass to the "
"``comparator_factory`` argument of each function.  Customization of "
"operators at this level is a rare use case.  See the documentation at "
":class:`.PropComparator` for an overview."
msgstr ""
"또한 :func:`.column_property`, :func:`.relationship`, :func:`.composite`\ 같은 ORM 수준 함수들은"
" :class:`.PropComparator` 서브클래스를 각 함수의 ``comparator_factory``\ 인자에 넣어줌으로서 "
"ORM 수준에서 연산자 재정의를 제공 한다. "
"ORM 수준에서 연사자 제정의는 매우 드문 케이스이다. 좀 더 자세한 정보는 :class:`.PropComparator`\ 절을 참조."

