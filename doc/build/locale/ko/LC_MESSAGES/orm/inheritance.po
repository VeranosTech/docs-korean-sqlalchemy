# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../orm/inheritance.rst:4
msgid "Mapping Class Inheritance Hierarchies"
msgstr "클래스 상속 구조 매핑하기"

#: ../../orm/inheritance.rst:6
msgid ""
"SQLAlchemy supports three forms of inheritance: **single table "
"inheritance**, where several types of classes are represented by a single"
" table, **concrete table inheritance**, where each type of class is "
"represented by independent tables, and **joined table inheritance**, "
"where the class hierarchy is broken up among dependent tables, each class"
" represented by its own table that only includes those attributes local "
"to that class."
msgstr ""
"SQLAlchemy\ 는 세가지 형태의 상속을 지원한다. **단일 테이블(single table) 상속**\ 은 여러 유형의 클래스를 하나의 "
"테이블로 대표하는 방식이다. **구체 테이블(concrete table) 상속**\ 은 각각의 클래스 유형이 독립적인 테이블로 대표되는 방식이다. "
"**조인 테이블(joined table) 상속**\ 은 클래스 상하관계를 이용하여 테이블을 분해하고 각각의 테이블은 해당 클래스에서만 필요한 "
"속성으로만 구성하는 방법이다."

#: ../../orm/inheritance.rst:13
msgid ""
"The most common forms of inheritance are single and joined table, while "
"concrete inheritance presents more configurational challenges."
msgstr ""
"가장 흔히 사용되는 방식은 단독 테이블 방식과 조인 테이블 방식이다. "
"구체 테이블 방식은 설정이 더 어렵다."

#: ../../orm/inheritance.rst:16
msgid ""
"When mappers are configured in an inheritance relationship, SQLAlchemy "
"has the ability to load elements :term:`polymorphically`, meaning that a "
"single query can return objects of multiple types."
msgstr ""
"상속관계에 있는 매퍼를 설정하면 SQLAlchemy가 데이터를 다형적으로(:term:`polymorphically`) 로드할 수 있다. "
"즉 하나의 쿼리로 여러가지 유형의 객체를 반환할 수 있다."

#: ../../orm/inheritance.rst:22
msgid ""
"::ref:`examples_inheritance` - complete examples of joined, single and "
"concrete inheritance"
msgstr ""
"::ref:`examples_inheritance` - 조인, 단일, 구체 테이블 상속에 대한 예제 "

#: ../../orm/inheritance.rst:28
msgid "Joined Table Inheritance"
msgstr "조인 테이블 상속"

#: ../../orm/inheritance.rst:30
msgid ""
"In joined table inheritance, each class along a hierarchy of classes is "
"represented by a distinct table.  Querying for a particular subclass in "
"the hierarchy will render as a SQL JOIN along all tables in its "
"inheritance path. If the queried class is the base class, the **default "
"behavior is to include only the base table** in a SELECT statement.   In "
"all cases, the ultimate class to instantiate for a given row is "
"determined by a discriminator column or an expression that works against "
"the base table.    When a subclass is loaded **only** against a base "
"table, resulting objects will have base attributes populated at first; "
"attributes that are local to the subclass will :term:`lazy load` when "
"they are accessed.    Alternatively, there are options which can change "
"the default behavior, allowing the query to include columns corresponding"
" to multiple tables/subclasses up front."
msgstr ""
"조인 테이블 상속 방식에서는 클래스의 상속관계에 있는 각각의 테이블은 모두 별개의 테이블로 표현된다. "
"상속관계 안의 특정 클래스에 대해 쿼리를 하면 해당 상속 경로에 있는 모든 테이블에 대해 SQL JOIN "
"연산을 하게 된다. 만약 질의 결과가 베이스 클래스면 SELECT 문안에 베이스 테이블만 포함하는게 "
"기본 동작이다. 모든 경우에 각 행에 대해 실제로 구현될 클래스는 구분자(discriminator) 컬럼이나 베이스 "
"테이블에 대한 연산식에 의해 결정된다. "
"서브클래스를 베이스 테이블에 대해서만 로드하면 그 결과로 나오는 객체는 우선 베이스 속성만 가진다. "
"해당 서브 클래스에만 있는 국지적 속성은 실제로 접근하는 순간에 :term:`lazy load` 방식으로 "
"로드된다. 이러한 기본 동작 방식을 바꿀 수 있는 옵션도 있다. 그렇게 되면 쿼리를 했을 때 여러개의 "
"테이블/서브클래스에 대응하는 컬럼을 바로 얻을 수 있다."

#: ../../orm/inheritance.rst:43
msgid ""
"The base class in a joined inheritance hierarchy is configured with "
"additional arguments that will refer to the polymorphic discriminator "
"column as well as the identifier for the base class::"
msgstr ""
"조인된 상속 계층에서 베이스 클래스는 다형 구분자(polymorphic discriminator) 컬럼과 "
"베이스 클래스에 대한 지시자(identifier)를 참조한다.::"

#: ../../orm/inheritance.rst:58
msgid ""
"Above, an additional column ``type`` is established to act as the "
"**discriminator**, configured as such using the "
":paramref:`.mapper.polymorphic_on` parameter.  This column will store a "
"value which indicates the type of object represented within the row. The "
"column may be of any datatype, though string and integer are the most "
"common."
msgstr ""
"위 코드에서 ``type``\ 컬럼이 :paramref:`.mapper.polymorphic_on`\ 파라미터를 사용하는 지시자 역할을 "
"하도록 설정되었다. 이 컬럼은 해당 행이 표현하는 객체의 유형을 나타내는 값을 저장한다. "
"이 컬럼은 어떤 자료형이어도 상관없지만 주로 문자열 또는 정수 자료형을 많이 사용한다. "

#: ../../orm/inheritance.rst:64
msgid ""
"While a polymorphic discriminator expression is not strictly necessary, "
"it is required if polymorphic loading is desired.   Establishing a simple"
" column on the base table is the easiest way to achieve this, however "
"very sophisticated inheritance mappings may even configure a SQL "
"expression such as a CASE statement as the polymorphic discriminator."
msgstr ""
"다형적 로딩을 원한다면 다형성 구분자 표현식이 반드시 필요하다. 베이스 테이블에서 컬럼 하나를 만드는게 "
"가장 간단한 방법이지만 상속구조가 복잡하면 SQL 표현식에 CASE 문 등을 다형석 지시자로 넣어야 할 수도 있다. "

#: ../../orm/inheritance.rst:72
msgid ""
"Currently, **only one discriminator column or SQL expression may be "
"configured for the entire inheritance hierarchy**, typically on the base-"
" most class in the hierarchy. \"Cascading\" polymorphic discriminator "
"expressions are not yet supported."
msgstr ""
"현재는 상속 구조에서 가장 베이스에 있는 클래스에 단 하나만의 지시자 컬럼이나 SQL 표현식을 넣고 "
"전체 상속 구조를 설정할 수 있다. 캐스케이딩(Cascading) 방식의 다형성 지시자 표현식은 아직 "
"지원하지 않는다. "

#: ../../orm/inheritance.rst:77
msgid ""
"We next define ``Engineer`` and ``Manager`` subclasses of ``Employee``. "
"Each contains columns that represent the attributes unique to the "
"subclass they represent. Each table also must contain a primary key "
"column (or columns), as well as a foreign key reference to the parent "
"table::"
msgstr ""
"다음으로 ``Employee``\ 클래스의 서브 클래스인 ``Engineer``\ 클래스와 ``Manager``\ "
"클래스를 정의한다. 각 클래스는 해당 서브클래스에만 있는 속성을 나타내는 컬럼을 가진다. "
"또 각 클래스는 프라이머리 키와 부모 테이블을 참조하는 외부 키 참조인 키를 가진다.::"

#: ../../orm/inheritance.rst:100
msgid ""
"It is most common that the foreign key constraint is established on the "
"same column or columns as the primary key itself, however this is not "
"required; a column distinct from the primary key may also be made to "
"refer to the parent via foreign key.  The way that a JOIN is constructed "
"from the base table to subclasses is also directly customizable, however "
"this is rarely necessary."
msgstr ""
"외부 키 조건은 프라이머리 키 컬럼에 직접 넣는 것이 보통이지만 반드시 그래야 하는 것은 아니다. "
"외부 키를 참조하는 별도의 컬럼을 만들어도 된다. 이렇게 하면 베이스 테이블과 서브 클래스를 "
"조인하는 방식을 사용자 마음대로 바꿀 수 있지만 이런게 필요한 경우는 실제로는 드믈다."

msgid "Joined inheritance primary keys"
msgstr "조인 상속 프라이머리 키"

#: ../../orm/inheritance.rst:108
msgid ""
"One natural effect of the joined table inheritance configuration is that "
"the identity of any mapped object can be determined entirely from rows  "
"in the base table alone. This has obvious advantages, so SQLAlchemy "
"always considers the primary key columns of a joined inheritance class to"
" be those of the base table only. In other words, the ``id`` columns of "
"both the ``engineer`` and ``manager`` tables are not used to locate "
"``Engineer`` or ``Manager`` objects - only the value in ``employee.id`` "
"is considered. ``engineer.id`` and ``manager.id`` are still of course "
"critical to the proper operation of the pattern overall as they are used "
"to locate the joined row, once the parent row has been determined within "
"a statement."
msgstr ""
"조인 테이블 상속 설정 방식을 쓰면 모든 객체는 베이스 테이블의 행들 중에 있게 된다. "
"이렇게 되었을 때의 장점은 조인된 상속 클래스의 프라이머리 키가 곧 베이스 클래스의 프라이머리 키가 된다. "
"즉, ``Engineer``\ 혹은 ``Manager``\ 객체를 참조할 때 ``engineer``\ 테이블과 ``manager``\ 테이블이 "
"필요하지 않다. ``employee.id`` 값만 있으면 된다. 물론 부모 테이블에서 행을 결정한 이후에는 "
"조인된 테이블의 행을 결정하는데 ``engineer.id``\ 와 ``manager.id``\ 가 여전히 필요하다. "

#: ../../orm/inheritance.rst:119
msgid ""
"With the joined inheritance mapping complete, querying against "
"``Employee`` will return a combination of ``Employee``, ``Engineer`` and "
"``Manager`` objects. Newly saved ``Engineer``, ``Manager``, and "
"``Employee`` objects will automatically populate the ``employee.type`` "
"column with the correct \"discriminator\" value in this case "
"``\"engineer\"``, ``\"manager\"``, or ``\"employee\"``, as appropriate."
msgstr ""
"조인 상속 매핑 설정이 끝나면 ``Employee`` 테이블에 대해 쿼리를 하면 "
"``Employee``, ``Engineer``, ``Manager`` 객체가 섞여서 반환된다. "
"이 객체들은 ``employee.type``  지시자 컬럼에 자동적으로 해당하는 지시자 값 즉 "
"``\"engineer\"``, ``\"manager\"``, ``\"employee\"``\ 가 들어가게 된다. "

#: ../../orm/inheritance.rst:127
msgid "Relationships with Joined Inheritance"
msgstr "조인 상속에서의 릴레이션쉽"

#: ../../orm/inheritance.rst:129
msgid ""
"Relationships are fully supported with joined table inheritance.   The "
"relationship involving a joined-inheritance class should target the class"
" in the hierarchy that also corresponds to the foreign key constraint; "
"below, as the ``employee`` table has a foreign key constraint back to the"
" ``company`` table, the relationships are set up between ``Company`` and "
"``Employee``::"
msgstr ""
"조인 테이블 상속에서도 릴레이션쉽을 완벽히 지원한다. "
"조인 상속 클래스를 포함하는 릴레이션은 외부 키 조건에 대응하는 클래스를 상속 구조 안에서 "
"찾아야 한다. 예를 들어 다음 코드에서 ``employee`` 테이블은  ``company`` 테이블에 대한 외부 키 조건이 "
"있기 때문에 ``Company`` 테이블과 ``Employee`` 테이블 간의 릴레이션쉽이 생긴다.::"

#: ../../orm/inheritance.rst:161
msgid ""
"If the foreign key constraint is on a table corresponding to a subclass, "
"the relationship should target that subclass instead.  In the example "
"below, there is a foreign key constraint from ``manager`` to ``company``,"
" so the relationships are established between the ``Manager`` and "
"``Company`` classes::"
msgstr ""
"만약 외부 키 조건이 서브클래스에 있으면 그 릴레이션쉽은 서브클래스와 생기게 된다. 다음 예에서 "
"``manager``\ 에서 ``company``\ 로 가는 외부 키 조건이 있으므로 ``Manager`` 클래스와 "
"``Company`` 클래스간의 릴레이션쉽에 생성되었다.::"

#: ../../orm/inheritance.rst:199
msgid ""
"Above, the ``Manager`` class will have a ``Manager.company`` attribute; "
"``Company`` will have a ``Company.managers`` attribute that always loads "
"against a join of the ``employee`` and ``manager`` tables together."
msgstr ""
"위 코드에서는 ``Manager`` 클래스는 ``Manager.company`` 속성을 가진다. "
"``Company`` 클래스도 ``employee`` 테이블과 ``manager`` 테이블을 조인한 결과를 로드하는 "
" ``Company.managers`` 속성을 가진다. "

#: ../../orm/inheritance.rst:204
msgid "Loading Joined Inheritance Mappings"
msgstr "조인 상속 매핑 로딩하기"

#: ../../orm/inheritance.rst:206
msgid ""
"See the sections :ref:`inheritance_loading_toplevel` and "
":ref:`loading_joined_inheritance` for background on inheritance loading "
"techniques, including configuration of tables to be queried both at "
"mapper configuration time as well as query time."
msgstr ""
"매핑 설정 시점과 쿼리 시점에 모두 쿼리가 가능하게 하려면 객체 로딩에 대해 설명한 "
":ref:`inheritance_loading_toplevel` 절과 :ref:`loading_joined_inheritance` 절을 참조한다."

#: ../../orm/inheritance.rst:214
msgid "Single Table Inheritance"
msgstr "단일 테이블 상속"

#: ../../orm/inheritance.rst:216
msgid ""
"Single table inheritance represents all attributes of all subclasses "
"within a single table.  A particular subclass that has attributes unique "
"to that class will persist them within columns in the table that are "
"otherwise NULL if the row refers to a different kind of object."
msgstr ""
"단일 테이블 상속 방식은 모든 클래스의 모든 속성을 하나의 테이블로 나타내는 것이다. "
"특정 서브클래스에만 있는 속성의 경우에는 해당 컬럼의 값을 사용하고 다른 클래스에서는 "
"이 컬럼의 값이 NULL이 된다. "

#: ../../orm/inheritance.rst:221
msgid ""
"Querying for a particular subclass in the hierarchy will render as a "
"SELECT against the base table, which will include a WHERE clause that "
"limits rows to those with a particular value or values present in the "
"discriminator column or expression."
msgstr ""
"특정 서브클래스에 대해 쿼리를 하면 모두 베이스 클래스에 대한 쿼리가 된다. 다만 WHERE 절을 써서 "
"구분자 컬럼/표현식에 특정한 값을 가진 행만 쿼리하게 만든다."

#: ../../orm/inheritance.rst:226
msgid ""
"Single table inheritance has the advantage of simplicity compared to "
"joined table inheritance; queries are much more efficient as only one "
"table needs to be involved in order to load objects of every represented "
"class."
msgstr ""
"단일 테이블 상속은 조인 테이블 상속 방식에 비해 단순하다는 장점이 있다. 쿼리가 하나의 테이블에 대해서만 "
"행해지므로 훨씬 효율적이다."

#: ../../orm/inheritance.rst:230
msgid ""
"Single-table inheritance configuration looks much like joined-table "
"inheritance, except only the base class specifies ``__tablename__``. A "
"discriminator column is also required on the base table so that classes "
"can be differentiated from each other."
msgstr ""
"단일 테이블 상속 방식의 설정도 조인 테이블 상속과 비슷하다. 다만 베이스 클래스만 "
" ``__tablename__`` 속성을 가진다. 클래스를 구분하는 구분자 컬럼도 베이스 테이블에 있어야 한다."

#: ../../orm/inheritance.rst:235
msgid ""
"Even though subclasses share the base table for all of their attributes, "
"when using Declarative,  :class:`.Column` objects may still be specified "
"on subclasses, indicating that the column is to be mapped only to that "
"subclass; the :class:`.Column` will be applied to the same base "
":class:`.Table` object::"
msgstr ""
"서브클래스들이 베이스클래스를 공유하지만 테이블 선언시 서브클래스의 :class:`.Column` 객체는 "
"해당 서브클래스에서만 지정한다. 실제로는 모든 :class:`.Column` 컬럼이 베이스 "
":class:`.Table` 객체에 적용된다. ::"

#: ../../orm/inheritance.rst:265
msgid ""
"Note that the mappers for the derived classes Manager and Engineer omit "
"the ``__tablename__``, indicating they do not have a mapped table of "
"their own."
msgstr ""
"상속 클래스인 Manager, Engineer의 매퍼는 ``__tablename__``\ 가 없다는 점에 주의하라. "
"이 클래스는 자신만의 테이블을 가지지 않기 때문이다. "

#: ../../orm/inheritance.rst:270
msgid "Relationships with Single Table Inheritance"
msgstr "단일 테이블 상속에서의 릴레이션쉽"

#: ../../orm/inheritance.rst:272
msgid ""
"Relationships are fully supported with single table inheritance.   "
"Configuration is done in the same manner as that of joined inheritance; a"
" foreign key attribute should be on the same class that's the \"foreign\""
" side of the relationship::"
msgstr ""
"단일 테이블 상속에서도 릴레이션쉽은 완벽하게 지원된다. 조인 상속과 같은 방식으로 설정하면 된다. "
"외부 키 속성은 릴레이션쉽의 \"외부\" 측에 정의해야 한다.::"

#: ../../orm/inheritance.rst:311
msgid ""
"Also, like the case of joined inheritance, we can create relationships "
"that involve a specific subclass.   When queried, the SELECT statement "
"will include a WHERE clause that limits the class selection to that "
"subclass or subclasses::"
msgstr ""
"또한 조인 상속의 경우와 마찬가지로 특정 서브클래스에 대한 릴레이션쉽도 만들 수 있다. "
"쿼리를 하면 SELECT 명령에 서브클래스를 제한하는 WHERE 절이 포함되게 된다.::"

#: ../../orm/inheritance.rst:352
msgid ""
"Above, the ``Manager`` class will have a ``Manager.company`` attribute; "
"``Company`` will have a ``Company.managers`` attribute that always loads "
"against the ``employee`` with an additional WHERE clause that limits rows"
" to those with ``type = 'manager'``."
msgstr ""
"위 코드에서 ``Manager`` 클래스는 ``Manager.company`` 속성을 가진다. "
"``Company`` 클래스도 ``Company.managers`` 속성을 가진다. 이 속성에는 "
"``type = 'manager'`` 조건의 WHERE 절이 추가되어 ``employee`` 테이블을 쿼리하게 된다."

#: ../../orm/inheritance.rst:358
msgid "Loading Single Inheritance Mappings"
msgstr "단일 상속 매핑에서 로딩하기"

#: ../../orm/inheritance.rst:360
msgid ""
"The loading techniques for single-table inheritance are mostly identical "
"to those used for joined-table inheritance, and a high degree of "
"abstraction is provided between these two mapping types such that it is "
"easy to switch between them as well as to intermix them in a single "
"hierarchy (just omit ``__tablename__`` from whichever subclasses are to "
"be single-inheriting). See the sections "
":ref:`inheritance_loading_toplevel` and :ref:`loading_single_inheritance`"
" for documentation on inheritance loading techniques, including "
"configuration of classes to be queried both at mapper configuration time "
"as well as query time."
msgstr ""
"단일 테이블 상속에서의 로딩 기법은 조인 테이블 상속의 경우와 거의 같다. "
"두 가지 매핑 유형을 쉽게 바꾸거나 하나의 상속 관계를 구현하는데 두가지 유형을 같이 사용할 수 있도록 "
"고수준의 추상화가 제공된다. (서브클래스에서 ``__tablename__`` 속성만 빼면 단일 상속 형태가 된다.) "
"상속 로딩 기법에 대한 문서는 :ref:`inheritance_loading_toplevel` 절과 "
":ref:`loading_single_inheritance` 절에서 제공한다. 여기에는 "
"매핑 시점과 쿼리 시점에 둘 다 쿼리할 수 있도록 클래스를 설정하는 방법도 나와 있다. "

#: ../../orm/inheritance.rst:373
msgid "Concrete Table Inheritance"
msgstr "구체 테이블 상속"

#: ../../orm/inheritance.rst:375
msgid ""
"Concrete inheritance maps each subclass to its own distinct table, each "
"of which contains all columns necessary to produce an instance of that "
"class. A concrete inheritance configuration by default queries non-"
"polymorphically; a query for a particular class will only query that "
"class' table and only return instances of that class.  Polymorphic "
"loading of concrete classes is enabled by configuring within the mapper a"
" special SELECT that typically is produced as a UNION of all the tables."
msgstr ""
"구체 상속에서는 각각의 서브클래스를 별도의 테이블로 구현하면서 각 테이블은 해당 클래스의 인스턴스를 "
"만드는데 필요한 모든 컬럼을 포함하도록 한다. "
"구체 상속 설정은 기본적으로 다형적 쿼리를 지원하지 않는다. 특정 클래스에 대한 쿼리는 실제로 해당 클래스 "
"테이블에 대한 쿼리가 되며 해당 클래스의 객체만 반환한다. 구체 상속에서 다형성 로딩을 하려면 "
"매퍼 안에 모든 테이블의 UNION을 만드는 특별한 SELECT 명령을 넣어야 한다. "

#: ../../orm/inheritance.rst:385
msgid ""
"Concrete table inheritance is **much more complicated** than joined or "
"single table inheritance, and is **much more limited in functionality** "
"especially pertaining to using it with relationships, eager loading, and "
"polymorphic loading.  When used polymorphically it produces **very large "
"queries** with UNIONS that won't perform as well as simple joins.  It is "
"strongly advised that if flexibility in relationship loading and "
"polymorphic loading is required, that joined or single table inheritance "
"be used if at all possible.   If polymorphic loading isn't required, then"
" plain non-inheriting mappings can be used if each class refers to its "
"own table completely."
msgstr ""
"구체 테이블 상속은 조인 테이블 상속이나 단일 테이블 상속보다 훨신 복잡하고 기능도 훨씬 제한된다. "
"특히 릴레이션쉽을 쓰거나 eager 로딩, 다형적 로딩이 제한된다. 다형 로딩을 하려고 하면 단일 조인으로 불가능하고 "
"UNIONS에 대해 쿼리를 해야 한다. 만약 릴레이션쉽 로딩, 다형성 로딩이 필요하면 가능한한 조인 상속이나 단일 테이블 "
"상속을 사용할 것을 강력하게 권장한다. 만약 다형성 로딩이 필요없으면 그냥 비-상속 미핑을 해서 "
"하나의 클래스가 하나의 테이블에 매핑되도록 하면 된다. "


#: ../../orm/inheritance.rst:396
msgid ""
"Whereas joined and single table inheritance are fluent in \"polymorphic\""
" loading, it is a more awkward affair in concrete inheritance.  For this "
"reason, concrete inheritance is more appropriate when **polymorphic "
"loading is not required**.   Establishing relationships that involve "
"concrete inheritance classes is also more awkward."
msgstr ""
"조인과 단일 테이블 상속은 \"poloymorphic\" 로딩이 비교적 자유롭지만, "
"구체 상속에서는 복잡하다. 이러한 이유로, 구체 상속은 **다형성 로딩이 필요하지 않을때** "
" 더 적절하다. 또한 구체 상속 클래스간 릴레이션쉽을 설정하는 것은 지양해야 한다."

#: ../../orm/inheritance.rst:402
msgid ""
"To establish a class as using concrete inheritance, add the "
":paramref:`.mapper.concrete` parameter within the ``__mapper_args__``. "
"This indicates to Declarative as well as the mapping that the superclass "
"table should not be considered as part of the mapping::"
msgstr ""
"구체 상속을 사용하여 클래스를 설정하려면, ``__mapper_args__``\ 안에 "
":paramref:`.mapper.concrete` 파라미터를 추가해야한다. "
"이것은 선언적(Declarative) 뿐만 아니라 매핑에서도 슈퍼 클래스 테이블이 "
"매핑의 일부로 간주되어서는 안된다는 점을 알려줍니다. "

#: ../../orm/inheritance.rst:435
msgid "Two critical points should be noted:"
msgstr "두 가지 중요한 점을 주목해야 한다:"

#: ../../orm/inheritance.rst:437
msgid ""
"We must **define all columns explicitly** on each subclass, even those of"
" the same name.  A column such as ``Employee.name`` here is **not** "
"copied out to the tables mapped by ``Manager`` or ``Engineer`` for us."
msgstr ""
"각 서브클래스의 **모든 컬럼들의 이름들이 모두 같더라도 명시적으로 정의** 해야 한다."
" ``Employee.name`` 컬럼은 ``Manager``\ 혹은 ``Engineer``\ 으로 매핑된 테이블로"
"복사되어져선 **안된다**. "

#: ../../orm/inheritance.rst:442
msgid ""
"while the ``Engineer`` and ``Manager`` classes are mapped in an "
"inheritance relationship with ``Employee``, they still **do not include "
"polymorphic loading**.  Meaning, if we query for ``Employee`` objects, "
"the ``manager`` and ``engineer`` tables are not queried at all."
msgstr ""
"이전 예제에서 ``Engineer``\ 과 ``Manager``\ 클래스들은 ``Employee``\ 의 상속 관계로 매핑되었습니다."
"이들은 **여전히 다형성 로딩이** 되지 않습니다. 이 의미는, ``Employee`` 객체들을 쿼리했을때, "
"``manager``\ 과 ``engineer``\ 테이블들은 전혀 쿼리되지 않습니다."

#: ../../orm/inheritance.rst:450
msgid "Concrete Polymorphic Loading Configuration"
msgstr "구체 다형성 로딩 설정"

#: ../../orm/inheritance.rst:452
msgid ""
"Polymorphic loading with concrete inheritance requires that a specialized"
" SELECT is configured against each base class that should have "
"polymorphic loading.  This SELECT needs to be capable of accessing all "
"the mapped tables individually, and is typically a UNION statement that "
"is constructed using a SQLAlchemy helper :func:`.polymorphic_union`."
msgstr ""
"구체 상속을 통한 polymorphic 로딩은 각각의 기본 클래스에 대해 정의된 SELECT가 구성되어야 합니다."
"이 SELECT는 매핑된 모든 테이블에 개별적으로 접근 가능 해야 하며, 일반적으로 SQLAlchemy helper "
":func:`.polymorphic_union`\ 을 사용한 UNION 문입니다."

#: ../../orm/inheritance.rst:458
msgid ""
"As discussed in :ref:`inheritance_loading_toplevel`, mapper inheritance "
"configurations of any type can be configured to load from a special "
"selectable by default using the :paramref:`.mapper.with_polymorphic` "
"argument.  Current public API requires that this argument is set on a "
":class:`.Mapper` when it is first constructed."
msgstr ""
":ref:`inheritance_loading_toplevel`\ 에서 설명했듯이, 모든 유형의 매퍼 상속 구성은 "
"기본적으로 :paramref:`.mapper.with_polymorphic`\ 을 사용하여 특정한 선택자(special selectable)"
"를 불러옴으로서 구성할 수 있습니다. 현재 공용 API는 처음 구성되어질때 이 인자를 :class:`.Mapper`\ 에 "
"설정해야 합니다."

#: ../../orm/inheritance.rst:464
msgid ""
"However, in the case of Declarative, both the mapper and the "
":class:`.Table` that is mapped are created at once, the moment the mapped"
" class is defined. This means that the "
":paramref:`.mapper.with_polymorphic` argument cannot be provided yet, "
"since the :class:`.Table` objects that correspond to the subclasses "
"haven't yet been defined."
msgstr ""
"그러나 선언적일(Declarative) 경우, 매핑된 클래스가 정의되는 순간에 매퍼와 매핑된 :class:`.Table`\ 가 동시시에 작성됩니다."
"이것은 :class:`.Table` 객체에 해당하는 서브클래스들이 아직 정의되지 않음으로 :paramref:`.mapper.with_polymorphic`\ 인자가 "
"제공되어질 수 없다는 것을 의미합니다."

#: ../../orm/inheritance.rst:470
msgid ""
"There are a few strategies available to resolve this cycle, however "
"Declarative provides helper classes :class:`.ConcreteBase` and "
":class:`.AbstractConcreteBase` which handle this issue behind the scenes."
msgstr ""
"이 주기를 해결하는 몇가지 방법이 존재하지만, 선언 시스템은 핼퍼 클래스 :class:`.ConcreteBase` 와"
":class:`.AbstractConcreteBase` 를 제공하여 해결하고 있습니다. 이 부분은 아래에서 더 자세하게 다루겠습니다."

#: ../../orm/inheritance.rst:474
msgid ""
"Using :class:`.ConcreteBase`, we can set up our concrete mapping in "
"almost the same way as we do other forms of inheritance mappings::"
msgstr ""
":class:`.ConcreteBase`\ 클래스를 사용하면 우리는 다른 매핑 방식과 거의 같은 방식으로 구체 매핑을 설정할 수 있다::"

#: ../../orm/inheritance.rst:511
msgid ""
"Above, Declarative sets up the polymorphic selectable for the "
"``Employee`` class at mapper \"initialization\" time; this is the late-"
"configuration step for mappers that resolves other dependent mappers.  "
"The :class:`.ConcreteBase` helper uses the :func:`.polymorphic_union` "
"function to create a UNION of all concrete-mapped tables after all the "
"other classes are set up, and then configures this statement with the "
"already existing base-class mapper."
msgstr ""
"위 코드에서 선언 시스템은 매퍼를 초기화 할때 ``Employee``\ 클래스에 다형성 선택자를 설정합니다."
"이것은 다른 종속 매퍼들을 해결하는 매퍼를 위한 늦은-구성(late-configuration) 단계입니다."
" :class:`.ConcreteBase`\ 핼퍼 클래스는 다른 모든 클래스들이 설정 완료되었을때 "
":func:`.polymorphic_union`\ 함수를 사용하여 먼저 구체-매핑 된 모든 테이블들의 UNION 문을 생성하고, 그 다음"
" 이미 존재하는 베이스-클래스 매퍼들과 함께 이 UNION 문을 완성합니다. "


#: ../../orm/inheritance.rst:519
msgid "Upon select, the polymorphic union produces a query like this:"
msgstr "SELECT 시, 다형성 UNION 은 다음과 같은 쿼리를 생성합니다:"

#: ../../orm/inheritance.rst:557
msgid ""
"The above UNION query needs to manufacture \"NULL\" columns for each "
"subtable in order to accommodate for those columns that aren't members of"
" that particular subclass."
msgstr ""
"위의 UNION 쿼리는 해당 하위 클래스의 구성원이 아닌 컬럼을 수용하기 위해 각 하위 테이블에 대해 \"NULL\" 컬럼을"
" 만들어야 합니다."

#: ../../orm/inheritance.rst:562
msgid "Abstract Concrete Classes"
msgstr "추상 구체 클래스"

#: ../../orm/inheritance.rst:564
msgid ""
"The concrete mappings illustrated thus far show both the subclasses as "
"well as the base class mapped to individual tables.   In the concrete "
"inheritance use case, it is common that the base class is not represented"
" within the database, only the subclasses.  In other words, the base "
"class is \"abstract\"."
msgstr ""
"지금까지 설명한 구체 매핑은 개별 테이블에 매핑된 기본 클래스는 물론 하위 클래스들 까지 보여줍니다."
"구체 상속 사용 사례에서는 기본 클래스가 데이터 베이스 내에서 표현되지 않고 하위 클래스만 표현하는 것이 일반적입니다."
" 다른말로 베이스 클래스는 \"추상적\" 입니다."

#: ../../orm/inheritance.rst:570
msgid ""
"Normally, when one would like to map two different subclasses to "
"individual tables, and leave the base class unmapped, this can be "
"achieved very easily. When using Declarative, just declare the base class"
" with the ``__abstract__`` indicator::"
msgstr ""
"일반적으로, 서로다른 두 서브 클래스들을 개별적인 테이블들에 매핑시키고, 베이스 클래스를 언매핑된 상태로 두고 싶다면 이것은"
"매우 쉽게 달성 될 수 있습니다. 선언적 시스템을 사용할때, 베이스 클래스에 ``__abstract__`` 를 선언합니다::"

#: ../../orm/inheritance.rst:598
msgid ""
"Above, we are not actually making use of SQLAlchemy's inheritance mapping"
" facilities; we can load and persist instances of ``Manager`` and "
"``Engineer`` normally.   The situation changes however when we need to "
"**query polymorphically**, that is, we'd like to emit "
"``session.query(Employee)`` and get back a collection of ``Manager`` and "
"``Engineer`` instances.    This brings us back into the domain of "
"concrete inheritance, and we must build a special mapper against "
"``Employee`` in order to achieve this."
msgstr ""
"위 코드에서 우리는 실제로 SQLAlchemy의 상속 매핑 기능을 사용하고 있지 않습니다. 하지만"
" ``Manager``\ 인스턴스와 ``Engineer``\ 인스턴스를 로딩하고 영속(persist) 할 수는 있습니다."
"그러나 다형성으로 쿼리해야하는 상황이 바뀌며, 즉 ``session.query(Employee)``\ 를 내보내고 "
"``Manager``\ 및 ``Engineer``\ 인스턴스 컬렉션을 되찾으려할때 우리는 ``Employee`` 에 대한 매퍼를 만들어야 합니다."

msgid "Mappers can always SELECT"
msgstr "매퍼는 항상 SELECT 문을 쓸수 있음"

#: ../../orm/inheritance.rst:608
msgid ""
"In SQLAlchemy, a mapper for a class always has to refer to some "
"\"selectable\", which is normally a :class:`.Table` but may also refer to"
" any :func:`.select` object as well.   While it may appear that a "
"\"single table inheritance\" mapper does not map to a table, these "
"mappers in fact implicitly refer to the table that is mapped by a "
"superclass."
msgstr ""
"SQLAlchemy, 클래스 매퍼는 항상 \"selectable\"을 참조해야 하는데, 이는 보통 :class:`.Table`\ 이거나 혹은"
" :func:`.select` 객체 입니다. \"단일 테이블 상속\"매퍼가 테이블에 매핑되지 않는 것처럼 보이지만, 실제로 "
"이러한 매퍼는 수퍼 클래스에 의해 매핑된 테이블을 암시적으로 참조합니다."

#: ../../orm/inheritance.rst:614
msgid ""
"To modify our concrete inheritance example to illustrate an \"abstract\" "
"base that is capable of polymorphic loading, we will have only an "
"``engineer`` and a ``manager`` table and no ``employee`` table, however "
"the ``Employee`` mapper will be mapped directly to the \"polymorphic "
"union\", rather than specifying it locally to the "
":paramref:`.mapper.with_polymorphic` parameter."
msgstr ""
"다형성 로딩을 할 수 있는 \"추상\" 베이스 클래스를 설명하기 위해 우리의 구상 상속 예제를 변경합니다."
"우리는 단지 ``engineer``\ 과 ``manager``\ 테이블을 갖고있고 ``employee``\ 테이블은 없습니다. 하지만, ``Employee`` 매퍼가"
" :paramref:`.mapper.with_polymorphic` 파라미터를 지정하지 않고 \"다형성 UNION\"에 직접적으로 매핑됩니다."

#: ../../orm/inheritance.rst:621
msgid ""
"To help with this, Declarative offers a variant of the "
":class:`.ConcreteBase` class called :class:`.AbstractConcreteBase` which "
"achieves this automatically::"
msgstr ""
"이것을 돕기 위해, 선언적 시스템은 :class:`.AbstractConcreteBase` 라고 불리는 "
"다양한 :class:`.ConcreteBase` 클래스를 제공합니다. 이 클래스를 통해 위의 과정을 자동적으로 달성합니다::"

#: ../../orm/inheritance.rst:651
msgid ""
"The :class:`.AbstractConcreteBase` helper class has a more complex "
"internal process than that of :class:`.ConcreteBase`, in that the entire "
"mapping of the base class must be delayed until all the subclasses have "
"been declared. With a mapping like the above, only instances of "
"``Manager`` and ``Engineer`` may be persised; querying against the "
"``Employee`` class will always produce ``Manager`` and ``Engineer`` "
"objects."
msgstr ""
":class:`.AbstractConcreteBase`\ 핼퍼 클래스는 모든 서브클래스들이 정의되기 전까지 "
"베이스 클래스의 매핑이 지연되기에 :class:`.ConcreteBase` 보다 더욱 복잡한 내부 프로세스를 가지고 있습니다."
"위의 코드를 보면, ``Manager``\ 과 ``Engineer``\ 인스턴스만 유지됩니다."
" ``Employee``\ 클래스에 대해 쿼리를 할 경우, ``Manager``\ 과 ``Engineer``\ 객체가 생성됩니다."

#: ../../orm/inheritance.rst:660
msgid ""
":ref:`declarative_concrete_table` - in the Declarative reference "
"documentation"
msgstr ""
":ref:`declarative_concrete_table` - 선언적 시스템에 대한 참조 문서"

#: ../../orm/inheritance.rst:663
msgid "Classical and Semi-Classical Concrete Polymorphic Configuration"
msgstr "고전적, 반-고전적 구체 다형성 구성"

#: ../../orm/inheritance.rst:665
msgid ""
"The Declarative configurations illustrated with :class:`.ConcreteBase` "
"and :class:`.AbstractConcreteBase` are equivalent to two other forms of "
"configuration that make use of :func:`.polymorphic_union` explicitly. "
"These configurational forms make use of the :class:`.Table` object "
"explicitly so that the \"polymorphic union\" can be created first, then "
"applied to the mappings.   These are illustrated here to clarify the role"
" of the :func:`.polymorphic_union` function in terms of mapping."
msgstr ""
"선언적 구성은(Declarative configurations)는 :class:`.ConcreteBase`\ 과"
":class:`.AbstractConcreteBase`\ 으로 명시되어 있으며, :func:`.polymorphic_union`\ "
"을 명시적으로 사용하는 두 가지 구성 형태와 동일합니다. 이러한 구성 형식은 :class:`.Table`\ "
"객체를 명시적으로 사용하기에 \"다형성 유니온(polymorphic union)\"\ 을 먼저 생성하고, "
"매핑을 적용합니다. 아래 예제는 :func:`.polymorphic_union` 함수의 역활을 매핑의 "
"측면에서 명확히 하는 것을 보여줍니다."

#: ../../orm/inheritance.rst:673
msgid ""
"A **semi-classical mapping** for example makes use of Declarative, but "
"establishes the :class:`.Table` objects separately::"
msgstr ""
"선언적 시스템의 **반-고전적 매핑** 예제. 하지만 :class:`.Table`\ 객체가 각각 "
"분리되서 선언되었습니다::"

#: ../../orm/inheritance.rst:698
msgid "Next, the UNION is produced using :func:`.polymorphic_union`::"
msgstr ""
"다음으로, :func:`.polymorphic_union`\ 을 사용하여 결합(UNION)을 만들어 냅니다::"

#: ../../orm/inheritance.rst:708
msgid ""
"With the above :class:`.Table` objects, the mappings can be produced "
"using \"semi-classical\" style, where we use Declarative in conjunction "
"with the ``__table__`` argument; our polymorphic union above is passed "
"via ``__mapper_args__`` to the :paramref:`.mapper.with_polymorphic` "
"parameter::"
msgstr ""
"위의 :class:`.Table` 객체를 사용하면, \"반-고전적\"\ 스타일로 매핑이 만들어집니다."
"여기서 우리는 선언적 시스템을 ``__table__``\  인자와 같이 사용할 수 있습니다."
"위의 다형성 결합(UNION)은 ``__mapper_args__``\ 인자를 "
":paramref:`.mapper.with_polymorphic`\ 의 파라미터로 넘겨줍니다."

#: ../../orm/inheritance.rst:733
msgid ""
"Alternatvely, the same :class:`.Table` objects can be used in fully "
"\"classical\" style, without using Declarative at all. A constructor "
"similar to that supplied by Declarative is illustrated::"
msgstr ""
"또다른 방법으로, 같은 :class:`.Table` 객체를 선언적 시스템의 사용 없이"
" 완전히 \"고전적인\"\ 스타일로 사용할 수 있습니다."
"선언적 시스템에서 사용했던 것과 비슷한 생성자(constructor)가 제공됩니다."

#: ../../orm/inheritance.rst:761
msgid ""
"The \"abstract\" example can also be mapped using \"semi-classical\" or "
"\"classical\" style.  The difference is that instead of applying the "
"\"polymorphic union\" to the :paramref:`.mapper.with_polymorphic` "
"parameter, we apply it directly as the mapped selectable on our basemost "
"mapper.  The semi-classical mapping is illustrated below::"
msgstr ""
"\"추상적\" 예제는 \"반-고전적\" 스타일이나 \"고전적\" 스타이로 매핑될 수 있습니다."
"차이점은 :paramref:`.mapper.with_polymorphic`\ 의 파라메터에 \"다형성 결합(UNION)\""
"을 적용하는 대신 base-most 매퍼에서 매핑된 선택 가능 항목(mapped selectable)을 적용하는"
" 것입니다."
"아래에 반-고전적 매핑에 대한 예제가 나와있습니다::"

#: ../../orm/inheritance.rst:794
msgid ""
"Above, we use :func:`.polymorphic_union` in the same manner as before, "
"except that we omit the ``employee`` table."
msgstr ""
"위에서 우리는 ``employee``\ 테이블을 생략한다는 것을 제외하곤, "
":func:`.polymorphic_union`\ 을 이전과 같은 방식으로 사용합니다. "

#: ../../orm/inheritance.rst:799
msgid ""
":ref:`classical_mapping` - background information on \"classical\" "
"mappings"
msgstr ""
":ref:`classical_mapping` - \"고전적\" 매핑에 대한 추가 정보"

#: ../../orm/inheritance.rst:804
msgid "Relationships with Concrete Inheritance"
msgstr "구체(Concrete) 상속과 관계(Relationships)"

#: ../../orm/inheritance.rst:806
msgid ""
"In a concrete inheritance scenario, mapping relationships is challenging "
"since the distinct classes do not share a table.    If the relationships "
"only involve specific classes, such as a relationship between ``Company``"
" in our previous examples and ``Manager``, special steps aren't needed as"
" these are just two related tables."
msgstr ""
"구체 상속을 사용하는 상황에서, 별개의 클래스들이 테이블을 공유하지 않기 때문에"
"관계 매핑이 쉽지 않습니다. 만약 이전 예제들의 ``Company``\ 과 ``Manager``\ 관계처럼"
"관계가 몇몇 특정한 클래스들만 포함한다면 별다른 추가적인 작업이 필요하지 않습니다."

#: ../../orm/inheritance.rst:812
msgid ""
"However, if ``Company`` is to have a one-to-many relationship to "
"``Employee``, indicating that the collection may include both "
"``Engineer`` and ``Manager`` objects, that implies that ``Employee`` must"
" have polymorphic loading capabilities and also that each table to be "
"related must have a foreign key back to the ``company`` table.  An "
"example of such a configuration is as follows::"
msgstr ""
"하지만, ``Company``\ 가 ``Employee``\ 와 일-대-다(one-to-many) 관계를 갖어야 한다면"
"(이때 ``Engineer``\ 과 ``Manager``\ 를 포함함), 이는 ``Employee``\ 가 반드시 "
"다형성 로딩 기능이 있어야 하며, 각각의 관계된 각각의 테이블들이 ``company`` 테이블로 돌아올 수 있는"
"외래키가 필요합니다. 이러한 구성에 대한 예제가 아래에 나와 있습니다::"

#: ../../orm/inheritance.rst:866ㄱ
msgid ""
"The next complexity with concrete inheritance and relationships involves "
"when we'd like one or all of ``Employee``, ``Manager`` and ``Engineer`` "
"to themselves refer back to ``Company``.   For this case, SQLAlchemy has "
"special behavior in that a :func:`.relationship` placed on ``Employee`` "
"which links to ``Company`` **does not work** against the ``Manager`` and "
"``Engineer`` classes, when exercised at the instance level.  Instead, a "
"distinct :func:`.relationship` must be applied to each class.   In order "
"to achieve bi-directional behavior in terms of three separate "
"relationships which serve as the opposite of ``Company.employees``, the "
":paramref:`.relationship.back_populates` parameter is used between each "
"of the relationships::"
msgstr ""
"다음 복잡한 구체 상속과 관계 예제는 만약 ``Employee``, ``Manager``, ``Engineer``\ "
"전부 혹은 하나가, 그들 스스로 ``Company``\ 를 참조하는 경우를 다룹니다."
"이러한 케이스에서, SQLAlchemy는 인스턴스 레벨에서 실행될때 :func:`.relationship`\ 에 배치된 "
"``Employee``\ 가 ``Company``\ 에 연결(links)될 수 있도록 하는 특별한 동작( ``Manager``\ "
"와 ``Engineer``\ 은 **연결되지 않음**)을 합니다. 이 특별한 동작을 하는 대신, 개별적인 "
":func:`.relationship`\ 함수가 각각의 클래스에 적용되어야 합니다."
"아래의 예제를 보면, 3개의 분리된 관계들의 양방향 동작(bi-directional)을 적용시키기 위해 "
":paramref:`.relationship.back_populates`\ 파라미터가 각각의 관계에 사용됩니다."

#: ../../orm/inheritance.rst:929
msgid ""
"The above limitation is related to the current implementation, including "
"that concrete inheriting classes do not share any of the attributes of "
"the superclass and therefore need distinct relationships to be set up."
msgstr ""
"위의 제한은 현재 구현과 관계되어 있습니다. 구체 상속 클래스들은 슈퍼 클래스들의 어떠한 "
"속성(attributes)를 공유하지 않으므로 위의 예제처럼 개별적인 관계가 필요합니다."

#: ../../orm/inheritance.rst:934
msgid "Loading Concrete Inheritance Mappings"
msgstr "구체 상속 매핑 불러오기"

#: ../../orm/inheritance.rst:936
msgid ""
"The options for loading with concrete inheritance are limited; generally,"
" if polymorphic loading is configured on the mapper using one of the "
"declarative concrete mixins, it can't be modified at query time in "
"current SQLAlchemy versions.   Normally, the "
":func:`.orm.with_polymorphic` function would be able to override the "
"style of loading used by concrete, however due to current limitations "
"this is not yet supported."
msgstr ""
"구체 상속을 불러오는 선택지는 제한되어있습니다. 일반적으로, 선언적 구체 믹스인"
"(declarative concrete mixins)을 사용하여 다형성 로딩을 매퍼에 구성하였다면 "
"현재 SQLAlechmy 버전을 기준으로 쿼리 시간(query time)에는 변경되지 않습니다."
" :func:`.orm.with_polymorphic`\ 함수는 구체 상속에서 사용하는 로딩 스타일을"
"덮어 쓸 수(override) 있습니다. 하지만 현재 제한 사항으로 인해 아직 지원하지 않고있습니다."
