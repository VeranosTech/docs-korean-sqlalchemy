# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2018, the SQLAlchemy authors and contributors
# This file is distributed under the same license as the SQLAlchemy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SQLAlchemy 1.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-02-21 14:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../core/tutorial.rst:5
msgid "SQL Expression Language Tutorial"
msgstr "SQL 표현식 언어 튜토리얼"

#: ../../core/tutorial.rst:7
msgid ""
"The SQLAlchemy Expression Language presents a system of representing "
"relational database structures and expressions using Python constructs. "
"These constructs are modeled to resemble those of the underlying database"
" as closely as possible, while providing a modicum of abstraction of the "
"various implementation differences between database backends. While the "
"constructs attempt to represent equivalent concepts between backends with"
" consistent structures, they do not conceal useful concepts that are "
"unique to particular subsets of backends. The Expression Language "
"therefore presents a method of writing backend-neutral SQL expressions, "
"but does not attempt to enforce that expressions are backend-neutral."
msgstr ""
"SQLAlchemy Expression Language(이하 `표현식 언어`\로 표기)는 Python 구문을 사용하여 관계형 데이터베이스 구조 및 표현을 나타내는 시스템을 제공한다. "
"이러한 구조는 데이터베이스 백엔드 간의 다양한 구현 차이에 대한 추상화를 제공하는 동시에 가능한 기본 데이터베이스와 유사하도록 모델링된다. "
"구조가 일관된 구조로 백엔드간에 동일한 개념을 표현하기 위해 시도하는 동안 백엔드의 특정 서브세트에 고유한 실용적인 개념을 숨기지는 않는다. "
"따라서 표현식 언어는 백엔드-중립적인(backend-neutral) SQL 표현식을 작성하는 방법을 제시하지만 백엔드-중립적인 표현식을 강요하지는 않는다."

#: ../../core/tutorial.rst:18
msgid ""
"The Expression Language is in contrast to the Object Relational Mapper, "
"which is a distinct API that builds on top of the Expression Language. "
"Whereas the ORM, introduced in :ref:`ormtutorial_toplevel`, presents a "
"high level and abstracted pattern of usage, which itself is an example of"
" applied usage of the Expression Language, the Expression Language "
"presents a system of representing the primitive constructs of the "
"relational database directly without opinion."
msgstr ""
"표현식 언어는 표현 언어를 기반으로한 ORM(Object Relational Mapper)"
"와 대조적입니다. :ref:`ormtutorial_toplevel`\ 에 소개된 ORM은 높은 수준의 추상화 패턴"
"을 사용하지만(이것 자체로도 표현식 언어의 응용), 표현식 언어는 관계형 데이터베이스의 "
"기본 구조를 직접 구현하는 시스템을 제공한다."


#: ../../core/tutorial.rst:26
msgid ""
"While there is overlap among the usage patterns of the ORM and the "
"Expression Language, the similarities are more superficial than they may "
"at first appear. One approaches the structure and content of data from "
"the perspective of a user-defined `domain model "
"<http://en.wikipedia.org/wiki/Domain_model>`_ which is transparently "
"persisted and refreshed from its underlying storage model. The other "
"approaches it from the perspective of literal schema and SQL expression "
"representations which are explicitly composed into messages consumed "
"individually by the database."
msgstr ""
"ORM과 표현식 언어의 사용 패턴이 겹치는 동안 유사점들은 처음에 나타날 수 있는 것"
"보다 더 피상적(superficial) 이다. 그 중 하나는 "
"사용자 정의 도메인 모델 `domain model <http://en.wikipedia.org/wiki/Domain_model>`_\ "
"의 관점에서 데이터의 구조와 내용에 접근하여 투명하게 유지되며 기본 저장소 모델에서 새로 고쳐진다는 것이다."
"다른 하나는 리터럴 스키마와 명시적으로 데이터베이스에서 개별적으로 소비되는 메시지로 구성된 "
"SQL 표현식(expression)의 표현들(representations)의 관점에서 접근한다."

#: ../../core/tutorial.rst:36
msgid ""
"A successful application may be constructed using the Expression Language"
" exclusively, though the application will need to define its own system "
"of translating application concepts into individual database messages and"
" from individual database result sets. Alternatively, an application "
"constructed with the ORM may, in advanced scenarios, make occasional "
"usage of the Expression Language directly in certain areas where specific"
" database interactions are required."
msgstr ""
"어플리케이션의 개념(concepts)을 개별 데이터베이스 메시지 및 개별 데이터베이스 결과 집합으로 변환하는"
"교유한 시스템을 어플리케이션내에서 정의해야 하지만, 표현식 언어를 독점적으로(exclusively) 사용하여 "
"성공적인 어플리케이션을 개발할 수 있다. 또는 ORM으로 구성된 어플리케이션의 경우 복잡한 시나리오에서 "
"데이터베이스와 상호작용이 필요한 특정 부분에 직접 표현식 언어를 간헐적으로 사용할 수 있다."

#: ../../core/tutorial.rst:44
msgid ""
"The following tutorial is in doctest format, meaning each ``>>>`` line "
"represents something you can type at a Python command prompt, and the "
"following text represents the expected return value. The tutorial has no "
"prerequisites."
msgstr ""
"아래의 튜토리얼은 doctest 형식으로 되어있다. 즉 ``>>>`` 행은 파이썬 명령 프롬프트에서 "
"입력 할 수 있는 것을 나타내며, 다음 텍스트는 예상되는 반환 값을 타나낸다."
"현재 튜토리얼에는 준비해야할것(prerequisites)이 없다."

#: ../../core/tutorial.rst:50
msgid "Version Check"
msgstr "버젼 확인"

#: ../../core/tutorial.rst:53
msgid ""
"A quick check to verify that we are on at least **version 1.3** of "
"SQLAlchemy:"
msgstr "우리가 가장 최신 버전인 **version 1.3**\ SQLAlchemy 를 사용하고 있는지 "
"확인:"

#: ../../core/tutorial.rst:62
msgid "Connecting"
msgstr "연결"

#: ../../core/tutorial.rst:64
msgid ""
"For this tutorial we will use an in-memory-only SQLite database. This is "
"an easy way to test things without needing to have an actual database "
"defined anywhere. To connect we use :func:`~sqlalchemy.create_engine`:"
msgstr ""
"이 튜토리얼을 위해 우리는 in-memory-only SQLite 데이터베이스를 사용한다."
"이것은 실제 데이터베이스를 가질 필요 없이 쉽게 어디서든 테스트를 할 수 있게 한다."
":func:`~sqlalchemy.create_engine`\ 함수를 통해 접속한다."

#: ../../core/tutorial.rst:73
msgid ""
"The ``echo`` flag is a shortcut to setting up SQLAlchemy logging, which "
"is accomplished via Python's standard ``logging`` module. With it "
"enabled, we'll see all the generated SQL produced. If you are working "
"through this tutorial and want less output generated, set it to "
"``False``. This tutorial will format the SQL behind a popup window so it "
"doesn't get in our way; just click the \"SQL\" links to see what's being "
"generated."
msgstr ""
"``echo`` 플래는 SQLAlchemy의 로깅 설정을 할 수 있는 가장 빠른 길이다. 이것은 "
"파이썬 표준 라이브러리인 ``logging`` 모듈을 사용한다. 이 설정이 허용되면 우리는 "
"SQL에서 생성된 것들을 볼 수 있다."

#: ../../core/tutorial.rst:80
msgid ""
"The return value of :func:`.create_engine` is an instance of "
":class:`.Engine`, and it represents the core interface to the database, "
"adapted through a :term:`dialect` that handles the details of the "
"database and :term:`DBAPI` in use.  In this case the SQLite dialect will "
"interpret instructions to the Python built-in ``sqlite3`` module."
msgstr ""
":func:`.create_engine`\ 함수에서 반환되는 값은 :class:`.Engine`\ 의 인스턴스 이다, "
"이것은 데이터베이스의 핵심 인터페이스를 나타내며 사용중인 데이터베이스 및 :term:`DBAPI`\ 의"
"세부 정보를 처리하는 :term:`dialect`\ 를 통해 핸들링된다. 이 경우 SQLite dialect는 파이썬"
"내장 모듈 ``sqlite3``\ 에 대한 명령어를 해석 한다."


msgid "Lazy Connecting"
msgstr "게으른 연결"

#: ../../core/tutorial.rst:89
msgid ""
"The :class:`.Engine`, when first returned by :func:`.create_engine`, has "
"not actually tried to connect to the database yet; that happens only the "
"first time it is asked to perform a task against the database."
msgstr ""
":func:`.create_engine`\ 함수에 의해 처음으로 반환되는 :class:`.Engine`\ 는 "
"사실 아직 데이터베이스에 연결을 하지 않았다. 데이터베이스에 대해 작업을 수행하라는 "
"메시지가 처음 실행될 때만 연결이 발생한다."

#: ../../core/tutorial.rst:93
msgid ""
"The first time a method like :meth:`.Engine.execute` or "
":meth:`.Engine.connect` is called, the :class:`.Engine` establishes a "
"real :term:`DBAPI` connection to the database, which is then used to emit"
" the SQL."
msgstr ""
":meth:`.Engine.execute`\ 함수나 :meth:`.Engine.connect`\ 함수가 처음 호출되었을때 "
":class:`.Engine`\ 클래스는 :term:`DBAPI`\ 연결을 데이터베이스와 설정한 다음"
" :term:`DBAPI`\ 을 통해 SQL을 내보낸다."

#: ../../core/tutorial.rst:99
msgid ""
":ref:`database_urls` - includes examples of :func:`.create_engine` "
"connecting to several kinds of databases with links to more information."
msgstr ""
":ref:`database_urls` - :func:`.create_engine`\ 함수를 통해 데이터베이스와 "
"연결하는 몇 가지 방법들에 대해 좀 더 자세한 설명과 예제가 나와있다."

#: ../../core/tutorial.rst:103
msgid "Define and Create Tables"
msgstr "테이블 정의와 생성"

#: ../../core/tutorial.rst:105
msgid ""
"The SQL Expression Language constructs its expressions in most cases "
"against table columns. In SQLAlchemy, a column is most often represented "
"by an object called :class:`~sqlalchemy.schema.Column`, and in all cases "
"a :class:`~sqlalchemy.schema.Column` is associated with a "
":class:`~sqlalchemy.schema.Table`. A collection of "
":class:`~sqlalchemy.schema.Table` objects and their associated child "
"objects is referred to as **database metadata**. In this tutorial we will"
" explicitly lay out several :class:`~sqlalchemy.schema.Table` objects, "
"but note that SA can also \"import\" whole sets of "
":class:`~sqlalchemy.schema.Table` objects automatically from an existing "
"database (this process is called **table reflection**)."
msgstr ""
"SQL 표현식 언어는 대부분의 경우 테이블 컬럼에 대한 표현식들을 생성한다. "
"SQLAlchemy 에서 대부분 컬럼은 :class:`~sqlalchemy.schema.Column`\ 객체를 호출됨으로서 표현되어지고, "
"모든 경우에서 :class:`~sqlalchemy.schema.Column`\ 은 :class:`~sqlalchemy.schema.Table`\ 과"
"연관되어져 있다. "
":class:`~sqlalchemy.schema.Table`\ 개체들의 컬랙션과 이들과 연관된 아직 객체들은 "
"**database metadata**\ 로 참조되어 진다. 이 튜토리얼에서 우리는 명시적으로 몇몇의 "
":class:`~sqlalchemy.schema.Table`\ 객체들을 배치하지만 SQLAlchemy는 또한 "
"이미 존재하는 데이베이스에서 :class:`~sqlalchemy.schema.Table`\ 객체 전체 집합을 자동적으로 "
"\"import\"\ 할 수 있다.(이 과정을 **테이블 리플렉션(table reflection)**\ 이라고 부른다.)"

#: ../../core/tutorial.rst:117
msgid ""
"We define our tables all within a catalog called "
":class:`~sqlalchemy.schema.MetaData`, using the "
":class:`~sqlalchemy.schema.Table` construct, which resembles regular SQL "
"CREATE TABLE statements. We'll make two tables, one of which represents "
"\"users\" in an application, and another which represents zero or more "
"\"email addresses\" for each row in the \"users\" table:"
msgstr ""
"우리는 일반적인 SQL CREATE TABLE문과 비슷한 뜻을 가진 :class:`~sqlalchemy.schema.Table`\ 객체 생성함으로서"
"모든 테이블들을 :class:`~sqlalchemy.schema.MetaData`\ 라 불리는 카테로그(catalog)에 정의했다."

#: ../../core/tutorial.rst:140
msgid ""
"All about how to define :class:`~sqlalchemy.schema.Table` objects, as "
"well as how to create them from an existing database automatically, is "
"described in :ref:`metadata_toplevel`."
msgstr ""
"이미 존재하는 데이터베이스에서 자동적으로 테이블 객체를 정의하는 방법부터 "
":class:`~sqlalchemy.schema.Table`\ 객체를 정의하는 모든 방법은 "
":ref:`metadata_toplevel`\ 에 설명되어 있다."

#: ../../core/tutorial.rst:144
msgid ""
"Next, to tell the :class:`~sqlalchemy.schema.MetaData` we'd actually like"
" to create our selection of tables for real inside the SQLite database, "
"we use :func:`~sqlalchemy.schema.MetaData.create_all`, passing it the "
"``engine`` instance which points to our database. This will check for the"
" presence of each table first before creating, so it's safe to call "
"multiple times:"
msgstr ""
"다음으로, :class:`~sqlalchemy.schema.MetaData`\ 을 말하자면 "
":class:`~sqlalchemy.schema.MetaData`\ 안에 있는 우리가 선택한 테이블들을 실제 SQLite 데이터 베이스 안에"
"생성하고 싶을땐 :func:`~sqlalchemy.schema.MetaData.create_all`\ 함수에 데이터베이스의 엔드포인트를 가르키는"
" ``engine``\ 객체를 넣어줌으로서 할 수 있다. 이렇게 하면 각 테이블을 생성하기 전에 테이블의 존재 여부를 먼저"
"확인하므로 여러 번 호출하는 것이 안전하다:"

#: ../../core/tutorial.rst:174
msgid ""
"Users familiar with the syntax of CREATE TABLE may notice that the "
"VARCHAR columns were generated without a length; on SQLite and "
"PostgreSQL, this is a valid datatype, but on others, it's not allowed. So"
" if running this tutorial on one of those databases, and you wish to use "
"SQLAlchemy to issue CREATE TABLE, a \"length\" may be provided to the "
":class:`~sqlalchemy.types.String` type as below::"
msgstr ""
"CREATE TABLE 문법과 친숙한 사용자들이라면 VARCHAR 컬럼들이 길이 없이 생성됨을 알아차렸을 "
"것이다. SQLite 와 PostgreSQL 에서 이것은 올바른 데이터 타입이지만 다른 데이터베이스에선 "
"이것이 허락되지 않는다. 따라서 아래 예제와 같이 다른 데이터베이스에서 이 튜토리얼을 실행하고 있다면, "
"SQLAlchemy를 사용하여 CREATE TABLE문을 사용할 땐 \"길이\" 를 :class:`~sqlalchemy.types.String`\ 에 "
"할당 해주어야 한다."

#: ../../core/tutorial.rst:183
msgid ""
"The length field on :class:`~sqlalchemy.types.String`, as well as similar"
" precision/scale fields available on :class:`~sqlalchemy.types.Integer`, "
":class:`~sqlalchemy.types.Numeric`, etc. are not referenced by SQLAlchemy"
" other than when creating tables."
msgstr ""
":class:`~sqlalchemy.types.String`\ 의 길이 항목처럼 "
":class:`~sqlalchemy.types.Integer`\ 와 :class:`~sqlalchemy.types.Numeric`\ "
"에서 마찬가지로 정밀도/스케일 항목이 존재한다. "

#: ../../core/tutorial.rst:187
msgid ""
"Additionally, Firebird and Oracle require sequences to generate new "
"primary key identifiers, and SQLAlchemy doesn't generate or assume these "
"without being instructed. For that, you use the "
":class:`~sqlalchemy.schema.Sequence` construct::"
msgstr ""
"추가적으로, Firebird와 오라클에선 새로운 프라이머리 키 식별자를 생성하기 위해 시퀸스가 필요하다."
"SQLAlchemy는 지시없이 이러한 식별자를 생성하거나 시퀸스를 가정하지 않는다. 이것을 위해 "
":class:`~sqlalchemy.schema.Sequence`\ 를 사용할 수 있다."

#: ../../core/tutorial.rst:194
msgid "A full, foolproof :class:`~sqlalchemy.schema.Table` is therefore::"
msgstr "따라서 완전한 :class:`~sqlalchemy.schema.Table`\ 구현은 다음과 같다::"

#: ../../core/tutorial.rst:203
msgid ""
"We include this more verbose :class:`~.schema.Table` construct separately"
" to highlight the difference between a minimal construct geared primarily"
" towards in-Python usage only, versus one that will be used to emit "
"CREATE TABLE statements on a particular set of backends with more "
"stringent requirements."
msgstr ""
"더 엄격한 요구 사항을 가진 특정 백엔드 세트에서 CREATE TABLE 문을 발행하는데 사용되는"
"것과 파이썬에서만 사용되는 최소 구문으로 CREATE TABLE 문을 발행하는데 사용되는 것의 차이를 "
"강조하기 위해 :class:`~.schema.Table`\ 에 좀 더 많은 구문(verbose)를 포함했다."

#: ../../core/tutorial.rst:212
msgid "Insert Expressions"
msgstr "삽입 표현식"

#: ../../core/tutorial.rst:214
msgid ""
"The first SQL expression we'll create is the "
":class:`~sqlalchemy.sql.expression.Insert` construct, which represents an"
" INSERT statement. This is typically created relative to its target "
"table::"
msgstr ""
"우리가 처음으로 만들 SQL 표현식은 :class:`~sqlalchemy.sql.expression.Insert`\ 구조이다."
"이것은 INSERT문을 표현하며, 이것은 일반적으로 타겟 테이블을 기준으로 생성되어 진다. "

#: ../../core/tutorial.rst:220
msgid ""
"To see a sample of the SQL this construct produces, use the ``str()`` "
"function::"
msgstr ""
"이 SQL이 생성하는 구조를 보려면 아래와 같이 ``str()`` 함수를 사용한다::"

#: ../../core/tutorial.rst:226
msgid ""
"Notice above that the INSERT statement names every column in the "
"``users`` table. This can be limited by using the ``values()`` method, "
"which establishes the VALUES clause of the INSERT explicitly::"
msgstr ""
"위에서 INSERT문이 ``user``\ 테이블의 모든 컬럼의 이름을 지정하는 것을 주목해라. "
"모든 컬럼의 이름을 지정하는 것을 제한할 수 있는데, ``values()`` 메소드 사용해서 INSERT문의 VALUES절을 명시적으로 "
"설정할 수 있다."

#: ../../core/tutorial.rst:234
msgid ""
"Above, while the ``values`` method limited the VALUES clause to just two "
"columns, the actual data we placed in ``values`` didn't get rendered into"
" the string; instead we got named bind parameters. As it turns out, our "
"data *is* stored within our :class:`~sqlalchemy.sql.expression.Insert` "
"construct, but it typically only comes out when the statement is actually"
" executed; since the data consists of literal values, SQLAlchemy "
"automatically generates bind parameters for them. We can peek at this "
"data for now by looking at the compiled form of the statement::"
msgstr ""
"위의 ``values``\ 메소드는 VALUES 절을 단지 두 개의 컬럼으로 제한했지만 실제로 배치한 데이터"
"``values``\ 는 문자열로 렌더링되지 않았다. 대신 우리는 이름이 설정된 바인드 매개 변수를 얻었다."
"결과적으로 **데이터는**  :class:`~sqlalchemy.sql.expression.Insert`\ 구조 내에 저장 되지만, 일반적으로 명령문이 "
"실제로 실행될 때만 나타납니다. 데이터가 리터럴 값으로 구성되므로 SQLAlchemy는 자동으로 "
"바인드 매개 변수를 생성합니다. 컴파일 된 형태의 명세서를 보면이 데이터를 볼 수 있습니다."


#: ../../core/tutorial.rst:247
msgid "Executing"
msgstr "실행"

#: ../../core/tutorial.rst:249
msgid ""
"The interesting part of an :class:`~sqlalchemy.sql.expression.Insert` is "
"executing it. In this tutorial, we will generally focus on the most "
"explicit method of executing a SQL construct, and later touch upon some "
"\"shortcut\" ways to do it. The ``engine`` object we created is a "
"repository for database connections capable of issuing SQL to the "
"database. To acquire a connection, we use the ``connect()`` method::"
msgstr ""
":class:`~sqlalchemy.sql.expression.Insert`\ 의 흥미로운 부분은 이것을 실행하는 것이다."
"이 튜토리얼에서 우리는 일반적으로 SQL 구문을 실행하는 가장 명확한 방법에 초점을 맞추고 "
"나중에 \"지름길\"을 통해 실행할 것이다. 우리가 생성한 ``engine``\ 객체는 데이터베이스에 "
"SQL을 발행할 수 있는 데이터 베이스 연결 케이블들의 저장소이다. 데이터베이스와 연결을 얻으려면"
" ``connect()``\ 함수를 사용한다::"

#: ../../core/tutorial.rst:260
msgid ""
"The :class:`~sqlalchemy.engine.Connection` object represents an actively "
"checked out DBAPI connection resource. Lets feed it our "
":class:`~sqlalchemy.sql.expression.Insert` object and see what happens:"
msgstr ""
":class:`~sqlalchemy.engine.Connection`\ 객체는 체크-아웃(checked-out) DBAPI 연결 자원을 나타낸다. "
":class:`~sqlalchemy.sql.expression.Insert`\ 객체에 피드를 보내고 어떤 일이 발생하는지 살펴 본다::"

#: ../../core/tutorial.rst:271
msgid ""
"So the INSERT statement was now issued to the database. Although we got "
"positional \"qmark\" bind parameters instead of \"named\" bind parameters"
" in the output. How come ? Because when executed, the "
":class:`~sqlalchemy.engine.Connection` used the SQLite **dialect** to "
"help generate the statement; when we use the ``str()`` function, the "
"statement isn't aware of this dialect, and falls back onto a default "
"which uses named parameters. We can view this manually as follows:"
msgstr ""
"이제 INSERT문이 데이터베이스에 발행되었습니다. \"명명 된\" 바인드 파라미터를 얻는 대신"
"위치적인(positional) \"?\"\ 바인드 파라미터를 얻었다. 왜냐하면 이것이 실행될때 "
":class:`~sqlalchemy.engine.Connection`\ 가 SQLite **dialect**\ 를 사용하여"
" 이 구문을 생성하기 때문이다. ``str()``\ 함수를 사용할 때, 명령문은 이 dialect를 인식"
" 하지 못하고 명명된 매개 변수를 사용하는 기본값으로 되돌아간다. 아래와 같이 이 과정을"
"수동으로 볼 수 있다:"

#: ../../core/tutorial.rst:285
msgid ""
"What about the ``result`` variable we got when we called ``execute()`` ? "
"As the SQLAlchemy :class:`~sqlalchemy.engine.Connection` object "
"references a DBAPI connection, the result, known as a "
":class:`~sqlalchemy.engine.ResultProxy` object, is analogous to the DBAPI"
" cursor object. In the case of an INSERT, we can get important "
"information from it, such as the primary key values which were generated "
"from our statement using :attr:`.ResultProxy.inserted_primary_key`:"
msgstr ""
"``execute()``\ 를 호출했을때 어떤 ``result``\ 변수를 받는가 ? "
":class:`~sqlalchemy.engine.ResultProxy`\ 객체로도 알려진 "
"DBAPI 연결을 참조하는 :class:`~sqlalchemy.engine.Connection`\ 객체는 DB"
":class:`~sqlalchemy.engine.Connection`\ 객체가 DBAPI 연결을 참조하므로, "
":class:`~sqlalchemy.engine.ResultProxy`\ 객체로도 알려져있는 **결과** 객체는 DBAPI의 "
"커서 객체와 유사하다. INSERT의 경우 :attr:`.ResultProxy.inserted_primary_key`\ 을 사용하여"
"우리의 명령문에서 생성된 기본 키 값과 같이 중요한 정보를 얻을 수 있다."

#: ../../core/tutorial.rst:298
msgid ""
"The value of ``1`` was automatically generated by SQLite, but only "
"because we did not specify the ``id`` column in our "
":class:`~sqlalchemy.sql.expression.Insert` statement; otherwise, our "
"explicit value would have been used. In either case, SQLAlchemy always "
"knows how to get at a newly generated primary key value, even though the "
"method of generating them is different across different databases; each "
"database's :class:`~sqlalchemy.engine.interfaces.Dialect` knows the "
"specific steps needed to determine the correct value (or values; note "
"that :attr:`.ResultProxy.inserted_primary_key` returns a list so that it "
"supports composite primary keys).    Methods here range from using "
"``cursor.lastrowid``, to selecting from a database-specific function, to "
"using ``INSERT..RETURNING`` syntax; this all occurs transparently."
msgstr ""
"``1``\ 값은 SQLite에 의해 자동적으로 생성되었지만, 우리가 :class:`~sqlalchemy.sql.expression.Insert`\ 문에 "
"``id`` 컬럼을 지정하지 않았기 때문에 발생했다. 이렇지 않으면 우리의가 지정한 명시적 값이 사용되었을 것이다."
"두 경우 모두 SQLAlchemy가 새로 생성된 기본 키 값을 생성하는 방법을 알고있고 심지어 종류가 다른 데이터베이스들의 "
" 각각 다른 방법이 존재해도 이는 유효하다."
"각 데이터베이스의 :class:`~sqlalchemy.engine.interfaces.Dialect`\ 는 올바른 값(또는 값; "
":attr:`.ResultProxy.inserted_primary_key`\ 는 복합 기본 키(composite primary key)를 생성하는 리스트를 반환함을"
"참고한다)을 결정하는 데 필요한 특정 단계을 알고 있다. 여기에는 ``cursor.lastrowid`` 부터 데이터베이스-지정 함수 선택,"
" ``INSERT..RETURNING``\ 까지 다양한 메소드들이 있다. 모든 것들이 투명하게 실행된다."

#: ../../core/tutorial.rst:314
msgid "Executing Multiple Statements"
msgstr "다중 구문 실행"

#: ../../core/tutorial.rst:316
msgid ""
"Our insert example above was intentionally a little drawn out to show "
"some various behaviors of expression language constructs. In the usual "
"case, an :class:`~sqlalchemy.sql.expression.Insert` statement is usually "
"compiled against the parameters sent to the ``execute()`` method on "
":class:`~sqlalchemy.engine.Connection`, so that there's no need to use "
"the ``values`` keyword with :class:`~sqlalchemy.sql.expression.Insert`. "
"Lets create a generic :class:`~sqlalchemy.sql.expression.Insert` "
"statement again and use it in the \"normal\" way:"
msgstr ""
"위의 INSERT 예제에서는 의도적으로 표현식 언어 구조들의 다양한 동작들이 어떻게 실행되는지 "
"보였다. 하지만 일반적으로 :class:`~sqlalchemy.sql.expression.Insert`\ 구문은 "
":class:`~sqlalchemy.engine.Connection`\ 클래스의 ``execute()``\ 함수의 파라미터를"
"지정하여 사용된다. 따라서 :class:`~sqlalchemy.sql.expression.Insert`\ 를 사용할때 "
"``values``\ 키워드는 사용될 필요가 없다. "
"제네릭 :class:`~sqlalchemy.sql.expression.Insert`\ 구문을 생성하고 그것을 "
"\"일반적인\" 방법으로 사용해 본다:"

#: ../../core/tutorial.rst:334
msgid ""
"Above, because we specified all three columns in the ``execute()`` "
"method, the compiled :class:`~.expression.Insert` included all three "
"columns. The :class:`~.expression.Insert` statement is compiled at "
"execution time based on the parameters we specified; if we specified "
"fewer parameters, the :class:`~.expression.Insert` would have fewer "
"entries in its VALUES clause."
msgstr ""
"위의 예제에서 우리가 ``execute()``\ 안에 있는 모든 세 컬럼을 지정했기 때문에 "
":class:`~.expression.Insert`\ 클래스는 이 모든 컬럼들을 컴파일 한다."
":class:`~.expression.Insert`\ 구문은 우리가 파라미터를 지정한 실행시간(execution-time)에"
" 컴파일된다. 만약 우리가 더 적은 파라미터를 지정했다면 :class:`~.expression.Insert`\ 는 "
"더 적은 VALUES 절을 포함했을 것이다."

#: ../../core/tutorial.rst:341
msgid ""
"To issue many inserts using DBAPI's ``executemany()`` method, we can send"
" in a list of dictionaries each containing a distinct set of parameters "
"to be inserted, as we do here to add some email addresses:"
msgstr ""
"DBAPI의 ``executemany()`` 함수를 사용하여 많은 INSERT를 발행한다면 "
"우리는 아래와 같이 INSERT될 각각의 파라미터를 포함하는 사전의 리스트를 ``execute()``\ 의 파라미터로 보낸다."

#: ../../core/tutorial.rst:358
msgid ""
"Above, we again relied upon SQLite's automatic generation of primary key "
"identifiers for each ``addresses`` row."
msgstr ""
"위의 예제에서, 우리는 또다시 각 ``addresses``\ 행에 SQLite 의 기본 키 식별자 자동 생성에 의존하였다. "

#: ../../core/tutorial.rst:361
msgid ""
"When executing multiple sets of parameters, each dictionary must have the"
" **same** set of keys; i.e. you cant have fewer keys in some dictionaries"
" than others. This is because the "
":class:`~sqlalchemy.sql.expression.Insert` statement is compiled against "
"the **first** dictionary in the list, and it's assumed that all "
"subsequent argument dictionaries are compatible with that statement."
msgstr ""
"다중 매개 변수 집합을 실행할때 각 사전에는 **동일한** 키 집합이 있어야 한다. 예를들어 어떤 사전에는 다른 것"
" 보다 적은 수의 키가 있을 수 있다. 이는 :class:`~sqlalchemy.sql.expression.Insert`\ 명령문이 "
"리스트의 **첫번재** 사전에 맞춰 컴파일되면, 나머지 모든 사전들은 이 컴파일 된 구문에 호환된다고 "
"가정한다는 것이다."

#: ../../core/tutorial.rst:368
msgid ""
"The \"executemany\" style of invocation is available for each of the "
":func:`.insert`, :func:`.update` and :func:`.delete` constructs."
msgstr ""
"\"executemany\"\ 같은 호출 스타일은 각각 :func:`.insert`, :func:`.update`, :func:`.delete` "
"구조에서 사용 가능하다."

#: ../../core/tutorial.rst:375
msgid "Selecting"
msgstr "Selecting"

#: ../../core/tutorial.rst:377
msgid ""
"We began with inserts just so that our test database had some data in it."
" The more interesting part of the data is selecting it! We'll cover "
"UPDATE and DELETE statements later. The primary construct used to "
"generate SELECT statements is the :func:`.select` function:"
msgstr ""
"위의 예제에서 우리는 INSERTS를 했으므로 테스트 데이테베이스는 그 데이터를 가지고 있다."
"그 데이터에 대한 더 흥미로운 부분은 그것을 selecting 하는것이다. UPDATE와 DELETE 구문은 나중에 "
"다룰 것이다. SELECT 구문을 생성하기 위한 기본 구조는 :func:`.select` 함수를 사용하는것이다:"

#: ../../core/tutorial.rst:391
msgid ""
"Above, we issued a basic :func:`.select` call, placing the ``users`` "
"table within the COLUMNS clause of the select, and then executing. "
"SQLAlchemy expanded the ``users`` table into the set of each of its "
"columns, and also generated a FROM clause for us. The result returned is "
"again a :class:`~sqlalchemy.engine.ResultProxy` object, which acts much "
"like a DBAPI cursor, including methods such as "
":func:`~sqlalchemy.engine.ResultProxy.fetchone` and "
":func:`~sqlalchemy.engine.ResultProxy.fetchall`. The easiest way to get "
"rows from it is to just iterate:"
msgstr ""
"위의 예제에서, 우리는 기본 :func:`.select`\ 함수를 호출하여 ``users``\ 테이블을"
"select의 COLUMNS 절 내에 놓고 그 다음 그것을 실행했다. SQLAlchemy는 ``users`` "
"테이블을 각 컬럼 집합으로 확장하고 FROM 절을 생성했다. 반환된 결과는 "
"DBAPI 커서와 같이 동작하는 :class:`~sqlalchemy.engine.ResultProxy`\ 객체이다. 이 객체는"
" :func:`~sqlalchemy.engine.ResultProxy.fetchone`\ 함수나"
" :func:`~sqlalchemy.engine.ResultProxy.fetchall`\ 함수를 포함하고 있다."
"가장 쉽게 행들을 가져오는 방법은 그냥 이터레이팅을 사용하는 것이다."

#: ../../core/tutorial.rst:408
msgid ""
"Above, we see that printing each row produces a simple tuple-like result."
" We have more options at accessing the data in each row. One very common "
"way is through dictionary access, using the string names of columns:"
msgstr ""
"위에서, 우리는 각 행을 프린트하면 각 행들의 간단한 튜플 객체 결과가 생성된다."
"우리는 각 행들의 데이터에 접근할 수 있는 더 많은 옵션들을 가질 수 있다. "
"가장 일반적인 방법 중 하나는 열의 문자열 이름을 사용하여 사전(dictionary) 액세스"
"를 사용하는 것이다:"

#: ../../core/tutorial.rst:423
msgid "Integer indexes work as well:"
msgstr "정수 인덱스들도 잘 작동한다:"

#: ../../core/tutorial.rst:431
msgid ""
"But another way, whose usefulness will become apparent later on, is to "
"use the :class:`~sqlalchemy.schema.Column` objects directly as keys:"
msgstr ""
"나중에 유용하게 쓰일 수 있는 또 다른 방법은, "
":class:`~sqlalchemy.schema.Column`\ 객체를 키로 직접 사용하는 것이다."

#: ../../core/tutorial.rst:444
msgid ""
"Result sets which have pending rows remaining should be explicitly closed"
" before discarding. While the cursor and connection resources referenced "
"by the :class:`~sqlalchemy.engine.ResultProxy` will be respectively "
"closed and returned to the connection pool when the object is garbage "
"collected, it's better to make it explicit as some database APIs are very"
" picky about such things:"
msgstr ""
"보류중인 행이 남아있는 결과 집합은 버리기 전에 명시적으로 닫아야 한다."
":class:`~sqlalchemy.engine.ResultProxy`\ 객체가 가비지-수집(garbage-collected)될 때"
"해당 객체에서 참조하는 커서 및 커낵션 리소스가 각각 닫히고 커낵션 풀로 리소스들이 반환되지만"
"일부 데이터베이스 API는 이러한 일에 매우 까다로우며 명시적으로 설정하는 것이 좋다:"

#: ../../core/tutorial.rst:455
msgid ""
"If we'd like to more carefully control the columns which are placed in "
"the COLUMNS clause of the select, we reference individual "
":class:`~sqlalchemy.schema.Column` objects from our "
":class:`~sqlalchemy.schema.Table`. These are available as named "
"attributes off the ``c`` attribute of the "
":class:`~sqlalchemy.schema.Table` object:"
msgstr ""
"select의 COLUMNS 절에 있는 열을 보다 세심하게 관리하려는 경우 우리는 "
":class:`~sqlalchemy.schema.Table`\ 객체로부터 개별적인 :class:`~sqlalchemy.schema.Column`\ "
"객체를 참조한다. 아래의 예제와 같이 이것들은 :class:`~sqlalchemy.schema.Table`\ 객채의 속성에서 ``c``\ 로 명명된 "
"속성으로 사용될 수 있다:"

#: ../../core/tutorial.rst:473
msgid ""
"Lets observe something interesting about the FROM clause. Whereas the "
"generated statement contains two distinct sections, a \"SELECT columns\" "
"part and a \"FROM table\" part, our :func:`.select` construct only has a "
"list containing columns. How does this work ? Let's try putting *two* "
"tables into our :func:`.select` statement:"
msgstr ""
"FROM 절에 대해 흥미로운 것을 관찰 할 수 있다. 생성된 명령문에는 \"SELECT columns\"\ 부분과"
"\"FROM table\"\ 부분의 두 개의 별개 섹션이 있지만, :func:`.select`\ 함수 구조는 단지 하나의"
"컬럼 리스트(users)만 가지고 있따. 어떻게 이것이 작동하는가 ? *두 개의* 테이블들을 "
":func:`.select`\ 구문에 넣어 보자:"

#: ../../core/tutorial.rst:495
msgid ""
"It placed **both** tables into the FROM clause. But also, it made a real "
"mess. Those who are familiar with SQL joins know that this is a "
"**Cartesian product**; each row from the ``users`` table is produced "
"against each row from the ``addresses`` table. So to put some sanity into"
" this statement, we need a WHERE clause.  We do that using "
":meth:`.Select.where`:"
msgstr ""
"**두개** 테이블들이 FROM 절에 위치되어 있지만, 이것은 완전히 엉망으로 만들어졌다. "
"SQL 조인(join)에 대해 친숙한 유저들은 이것이 **Cartesian product**\ 인 것을 알것이다. "
"``users``\ 테이블의 각 행들 중 ``addresses`` 테이블의 각 행들과 대응하는 것들만 생성된다. "
"그래서 이 구문을 좀 정리해보자면 우리는 WHERE 절이 필요하다. 우리는 이것을 "
":meth:`.Select.where`\ 함수를 사용함으로서 할 수 있다."

#: ../../core/tutorial.rst:516
msgid ""
"So that looks a lot better, we added an expression to our :func:`.select`"
" which had the effect of adding ``WHERE users.id = addresses.user_id`` to"
" our statement, and our results were managed down so that the join of "
"``users`` and ``addresses`` rows made sense. But let's look at that "
"expression? It's using just a Python equality operator between two "
"different :class:`~sqlalchemy.schema.Column` objects. It should be clear "
"that something is up. Saying ``1 == 1`` produces ``True``, and ``1 == 2``"
" produces ``False``, not a WHERE clause. So lets see exactly what that "
"expression is doing:"
msgstr ""
""

#: ../../core/tutorial.rst:530
msgid ""
"Wow, surprise ! This is neither a ``True`` nor a ``False``. Well what is "
"it ?"
msgstr ""

#: ../../core/tutorial.rst:537
msgid ""
"As you can see, the ``==`` operator is producing an object that is very "
"much like the :class:`~.expression.Insert` and :func:`.select` objects "
"we've made so far, thanks to Python's ``__eq__()`` builtin; you call "
"``str()`` on it and it produces SQL. By now, one can see that everything "
"we are working with is ultimately the same type of object. SQLAlchemy "
"terms the base class of all of these expressions as "
":class:`~.expression.ColumnElement`."
msgstr ""

#: ../../core/tutorial.rst:545
msgid "Operators"
msgstr ""

#: ../../core/tutorial.rst:547
msgid ""
"Since we've stumbled upon SQLAlchemy's operator paradigm, let's go "
"through some of its capabilities. We've seen how to equate two columns to"
" each other:"
msgstr ""

#: ../../core/tutorial.rst:555
msgid ""
"If we use a literal value (a literal meaning, not a SQLAlchemy clause "
"object), we get a bind parameter:"
msgstr ""

#: ../../core/tutorial.rst:563
msgid ""
"The ``7`` literal is embedded the resulting "
":class:`~.expression.ColumnElement`; we can use the same trick we did "
"with the :class:`~sqlalchemy.sql.expression.Insert` object to see it:"
msgstr ""

#: ../../core/tutorial.rst:572
msgid ""
"Most Python operators, as it turns out, produce a SQL expression here, "
"like equals, not equals, etc.:"
msgstr ""

#: ../../core/tutorial.rst:588
msgid "If we add two integer columns together, we get an addition expression:"
msgstr ""

#: ../../core/tutorial.rst:595
msgid ""
"Interestingly, the type of the :class:`~sqlalchemy.schema.Column` is "
"important! If we use ``+`` with two string based columns (recall we put "
"types like :class:`~sqlalchemy.types.Integer` and "
":class:`~sqlalchemy.types.String` on our "
":class:`~sqlalchemy.schema.Column` objects at the beginning), we get "
"something different:"
msgstr ""

#: ../../core/tutorial.rst:606
msgid ""
"Where ``||`` is the string concatenation operator used on most databases."
" But not all of them. MySQL users, fear not:"
msgstr ""

#: ../../core/tutorial.rst:615
msgid ""
"The above illustrates the SQL that's generated for an "
":class:`~sqlalchemy.engine.Engine` that's connected to a MySQL database; "
"the ``||`` operator now compiles as MySQL's ``concat()`` function."
msgstr ""

#: ../../core/tutorial.rst:619
msgid ""
"If you have come across an operator which really isn't available, you can"
" always use the :meth:`.Operators.op` method; this generates whatever "
"operator you need:"
msgstr ""

#: ../../core/tutorial.rst:627
msgid ""
"This function can also be used to make bitwise operators explicit. For "
"example::"
msgstr ""

#: ../../core/tutorial.rst:631
msgid "is a bitwise AND of the value in ``somecolumn``."
msgstr ""

#: ../../core/tutorial.rst:633
msgid ""
"When using :meth:`.Operators.op`, the return type of the expression may "
"be important, especialy when the operator is used in an expression that "
"will be sent as a result column.   For this case, be sure to make the "
"type explicit, if not what's normally expected, using "
":func:`.type_coerce`::"
msgstr ""

#: ../../core/tutorial.rst:643
msgid ""
"For boolean operators, use the :meth:`.Operators.bool_op` method, which "
"will ensure that the return type of the expression is handled as "
"boolean::"
msgstr ""

#: ../../core/tutorial.rst:648
msgid "Added the :meth:`.Operators.bool_op` method."
msgstr ""

#: ../../core/tutorial.rst:651
msgid "Operator Customization"
msgstr ""

#: ../../core/tutorial.rst:653
msgid ""
"While :meth:`.Operators.op` is handy to get at a custom operator in a "
"hurry, the Core supports fundamental customization and extension of the "
"operator system at the type level.   The behavior of existing operators "
"can be modified on a per-type basis, and new operations can be defined "
"which become available for all column expressions that are part of that "
"particular type.  See the section :ref:`types_operators` for a "
"description."
msgstr ""

#: ../../core/tutorial.rst:663
msgid "Conjunctions"
msgstr ""

#: ../../core/tutorial.rst:666
msgid ""
"We'd like to show off some of our operators inside of :func:`.select` "
"constructs. But we need to lump them together a little more, so let's "
"first introduce some conjunctions. Conjunctions are those little words "
"like AND and OR that put things together. We'll also hit upon NOT. "
":func:`.and_`, :func:`.or_`, and :func:`.not_` can work from the "
"corresponding functions SQLAlchemy provides (notice we also throw in a "
":meth:`~.ColumnOperators.like`):"
msgstr ""

#: ../../core/tutorial.rst:692
msgid ""
"And you can also use the re-jiggered bitwise AND, OR and NOT operators, "
"although because of Python operator precedence you have to watch your "
"parenthesis:"
msgstr ""

#: ../../core/tutorial.rst:710
msgid ""
"So with all of this vocabulary, let's select all users who have an email "
"address at AOL or MSN, whose name starts with a letter between \"m\" and "
"\"z\", and we'll also generate a column containing their full name "
"combined with their email address. We will add two new constructs to this"
" statement, :meth:`~.ColumnOperators.between` and "
":meth:`~.ColumnElement.label`. :meth:`~.ColumnOperators.between` produces"
" a BETWEEN clause, and :meth:`~.ColumnElement.label` is used in a column "
"expression to produce labels using the ``AS`` keyword; it's recommended "
"when selecting from expressions that otherwise would not have a name:"
msgstr ""

#: ../../core/tutorial.rst:743
msgid ""
"Once again, SQLAlchemy figured out the FROM clause for our statement. In "
"fact it will determine the FROM clause based on all of its other bits; "
"the columns clause, the where clause, and also some other elements which "
"we haven't covered yet, which include ORDER BY, GROUP BY, and HAVING."
msgstr ""

#: ../../core/tutorial.rst:748
msgid ""
"A shortcut to using :func:`.and_` is to chain together multiple "
":meth:`~.Select.where` clauses.   The above can also be written as:"
msgstr ""

#: ../../core/tutorial.rst:772
msgid ""
"The way that we can build up a :func:`.select` construct through "
"successive method calls is called :term:`method chaining`."
msgstr ""

#: ../../core/tutorial.rst:778
msgid "Using Textual SQL"
msgstr ""

#: ../../core/tutorial.rst:780
msgid ""
"Our last example really became a handful to type. Going from what one "
"understands to be a textual SQL expression into a Python construct which "
"groups components together in a programmatic style can be hard. That's "
"why SQLAlchemy lets you just use strings, for those cases when the SQL is"
" already known and there isn't a strong need for the statement to support"
" dynamic features.  The :func:`~.expression.text` construct is used to "
"compose a textual statement that is passed to the database mostly "
"unchanged.  Below, we create a :func:`~.expression.text` object and "
"execute it:"
msgstr ""

#: ../../core/tutorial.rst:807
msgid ""
"Above, we can see that bound parameters are specified in "
":func:`~.expression.text` using the named colon format; this format is "
"consistent regardless of database backend.  To send values in for the "
"parameters, we passed them into the :meth:`~.Connection.execute` method "
"as additional arguments."
msgstr ""

#: ../../core/tutorial.rst:814
msgid "Specifying Bound Parameter Behaviors"
msgstr ""

#: ../../core/tutorial.rst:816
msgid ""
"The :func:`~.expression.text` construct supports pre-established bound "
"values using the :meth:`.TextClause.bindparams` method::"
msgstr ""

#: ../../core/tutorial.rst:822
msgid "The parameters can also be explicitly typed::"
msgstr ""

#: ../../core/tutorial.rst:827
msgid ""
"Typing for bound parameters is necessary when the type requires Python-"
"side or special SQL-side processing provided by the datatype."
msgstr ""

#: ../../core/tutorial.rst:832
msgid ":meth:`.TextClause.bindparams` - full method description"
msgstr ""

#: ../../core/tutorial.rst:837
msgid "Specifying Result-Column Behaviors"
msgstr ""

#: ../../core/tutorial.rst:839
msgid ""
"We may also specify information about the result columns using the "
":meth:`.TextClause.columns` method; this method can be used to specify "
"the return types, based on name::"
msgstr ""

#: ../../core/tutorial.rst:845
msgid ""
"or it can be passed full column expressions positionally, either typed or"
" untyped.  In this case it's a good idea to list out the columns "
"explicitly within our textual SQL, since the correlation of our column "
"expressions to the SQL will be done positionally::"
msgstr ""

#: ../../core/tutorial.rst:853
msgid ""
"When we call the :meth:`.TextClause.columns` method, we get back a "
":class:`.TextAsFrom` object that supports the full suite of "
":attr:`.TextAsFrom.c` and other \"selectable\" operations::"
msgstr ""

#: ../../core/tutorial.rst:862
msgid ""
"The positional form of :meth:`.TextClause.columns` is particularly useful"
" when relating textual SQL to existing Core or ORM models, because we can"
" use column expressions directly without worrying about name conflicts or"
" other issues with the result column names in the textual SQL:"
msgstr ""

#: ../../core/tutorial.rst:886
msgid ""
"Above, there's three columns in the result that are named \"id\", but "
"since we've associated these with column expressions positionally, the "
"names aren't an issue when the result-columns are fetched using the "
"actual column object as a key. Fetching the ``email_address`` column "
"would be::"
msgstr ""

#: ../../core/tutorial.rst:895
msgid ""
"If on the other hand we used a string column key, the usual rules of "
"name- based matching still apply, and we'd get an ambiguous column error "
"for the ``id`` value::"
msgstr ""

#: ../../core/tutorial.rst:904
msgid ""
"It's important to note that while accessing columns from a result set "
"using :class:`.Column` objects may seem unusual, it is in fact the only "
"system used by the ORM, which occurs transparently beneath the facade of "
"the :class:`~.orm.query.Query` object; in this way, the "
":meth:`.TextClause.columns` method is typically very applicable to "
"textual statements to be used in an ORM context.   The example at "
":ref:`orm_tutorial_literal_sql` illustrates a simple usage."
msgstr ""

#: ../../core/tutorial.rst:914
msgid ""
"The :meth:`.TextClause.columns` method now accepts column expressions "
"which will be matched positionally to a plain text SQL result set, "
"eliminating the need for column names to match or even be unique in the "
"SQL statement when matching table metadata or ORM models to textual SQL."
msgstr ""

#: ../../core/tutorial.rst:921
msgid ":meth:`.TextClause.columns` - full method description"
msgstr ""

#: ../../core/tutorial.rst:923
msgid ""
":ref:`orm_tutorial_literal_sql` - integrating ORM-level queries with "
":func:`.text`"
msgstr ""

#: ../../core/tutorial.rst:928
msgid "Using text() fragments inside bigger statements"
msgstr ""

#: ../../core/tutorial.rst:930
msgid ""
":func:`~.expression.text` can also be used to produce fragments of SQL "
"that can be freely within a :func:`~.expression.select` object, which "
"accepts :func:`~.expression.text` objects as an argument for most of its "
"builder functions. Below, we combine the usage of "
":func:`~.expression.text` within a :func:`.select` object.  The "
":func:`~.expression.select` construct provides the \"geometry\" of the "
"statement, and the :func:`~.expression.text` construct provides the "
"textual content within this form.  We can build a statement without the "
"need to refer to any pre-established :class:`.Table` metadata:"
msgstr ""

#: ../../core/tutorial.rst:962
msgid ""
"The :func:`.select` construct emits warnings when string SQL fragments "
"are coerced to :func:`.text`, and :func:`.text` should be used "
"explicitly.  See :ref:`migration_2992` for background."
msgstr ""

#: ../../core/tutorial.rst:972
msgid ""
"Using More Specific Text with :func:`.table`, :func:`.literal_column`, "
"and :func:`.column`"
msgstr ""

#: ../../core/tutorial.rst:974
msgid ""
"We can move our level of structure back in the other direction too, by "
"using :func:`~.expression.column`, :func:`~.expression.literal_column`, "
"and :func:`~.expression.table` for some of the key elements of our "
"statement.   Using these constructs, we can get some more expression "
"capabilities than if we used :func:`~.expression.text` directly, as they "
"provide to the Core more information about how the strings they store are"
" to be used, but still without the need to get into full :class:`.Table` "
"based metadata.  Below, we also specify the :class:`.String` datatype for"
" two of the key :func:`~.expression.literal_column` objects, so that the "
"string-specific concatenation operator becomes available. We also use "
":func:`~.expression.literal_column` in order to use table-qualified "
"expressions, e.g. ``users.fullname``, that will be rendered as is; using "
":func:`~.expression.column` implies an individual column name that may be"
" quoted:"
msgstr ""

#: ../../core/tutorial.rst:1018
msgid "Ordering or Grouping by a Label"
msgstr ""

#: ../../core/tutorial.rst:1020
msgid ""
"One place where we sometimes want to use a string as a shortcut is when "
"our statement has some labeled column element that we want to refer to in"
" a place such as the \"ORDER BY\" or \"GROUP BY\" clause; other "
"candidates include fields within an \"OVER\" or \"DISTINCT\" clause.  If "
"we have such a label in our :func:`.select` construct, we can refer to it"
" directly by passing the string straight into :meth:`.select.order_by` or"
" :meth:`.select.group_by`, among others.  This will refer to the named "
"label and also prevent the expression from being rendered twice.  Label "
"names that resolve to columns are rendered fully:"
msgstr ""

#: ../../core/tutorial.rst:1044
msgid ""
"We can use modifiers like :func:`.asc` or :func:`.desc` by passing the "
"string name:"
msgstr ""

#: ../../core/tutorial.rst:1061
msgid ""
"Note that the string feature here is very much tailored to when we have "
"already used the :meth:`~.ColumnElement.label` method to create a "
"specifically-named label.  In other cases, we always want to refer to the"
" :class:`.ColumnElement` object directly so that the expression system "
"can make the most effective choices for rendering.  Below, we illustrate "
"how using the :class:`.ColumnElement` eliminates ambiguity when we want "
"to order by a column name that appears more than once:"
msgstr ""

#: ../../core/tutorial.rst:1088
msgid "Using Aliases"
msgstr ""

#: ../../core/tutorial.rst:1090
msgid ""
"The alias in SQL corresponds to a \"renamed\" version of a table or "
"SELECT statement, which occurs anytime you say \"SELECT .. FROM sometable"
" AS someothername\". The ``AS`` creates a new name for the table. Aliases"
" are a key construct as they allow any table or subquery to be referenced"
" by a unique name. In the case of a table, this allows the same table to "
"be named in the FROM clause multiple times. In the case of a SELECT "
"statement, it provides a parent name for the columns represented by the "
"statement, allowing them to be referenced relative to this name."
msgstr ""

#: ../../core/tutorial.rst:1099
msgid ""
"In SQLAlchemy, any :class:`.Table`, :func:`.select` construct, or other "
"selectable can be turned into an alias using the "
":meth:`.FromClause.alias` method, which produces a :class:`.Alias` "
"construct.  As an example, suppose we know that our user ``jack`` has two"
" particular email addresses. How can we locate jack based on the "
"combination of those two addresses?   To accomplish this, we'd use a join"
" to the ``addresses`` table, once for each address.   We create two "
":class:`.Alias` constructs against ``addresses``, and then use them both "
"within a :func:`.select` construct:"
msgstr ""

#: ../../core/tutorial.rst:1128
msgid ""
"Note that the :class:`.Alias` construct generated the names "
"``addresses_1`` and ``addresses_2`` in the final SQL result.  The "
"generation of these names is determined by the position of the construct "
"within the statement.   If we created a query using only the second "
"``a2`` alias, the name would come out as ``addresses_1``.  The generation"
" of the names is also *deterministic*, meaning the same SQLAlchemy "
"statement construct will produce the identical SQL string each time it is"
" rendered for a particular dialect."
msgstr ""

#: ../../core/tutorial.rst:1136
msgid ""
"Since on the outside, we refer to the alias using the :class:`.Alias` "
"construct itself, we don't need to be concerned about the generated name."
"  However, for the purposes of debugging, it can be specified by passing "
"a string name to the :meth:`.FromClause.alias` method::"
msgstr ""

#: ../../core/tutorial.rst:1143
msgid ""
"Aliases can of course be used for anything which you can SELECT from, "
"including SELECT statements themselves. We can self-join the ``users`` "
"table back to the :func:`.select` we've created by making an alias of the"
" entire statement. The ``correlate(None)`` directive is to avoid "
"SQLAlchemy's attempt to \"correlate\" the inner ``users`` table with the "
"outer one:"
msgstr ""

#: ../../core/tutorial.rst:1166
msgid "Using Joins"
msgstr ""

#: ../../core/tutorial.rst:1168
msgid ""
"We're halfway along to being able to construct any SELECT expression. The"
" next cornerstone of the SELECT is the JOIN expression. We've already "
"been doing joins in our examples, by just placing two tables in either "
"the columns clause or the where clause of the :func:`.select` construct. "
"But if we want to make a real \"JOIN\" or \"OUTERJOIN\" construct, we use"
" the :meth:`~.FromClause.join` and :meth:`~.FromClause.outerjoin` "
"methods, most commonly accessed from the left table in the join:"
msgstr ""

#: ../../core/tutorial.rst:1181
msgid ""
"The alert reader will see more surprises; SQLAlchemy figured out how to "
"JOIN the two tables ! The ON condition of the join, as it's called, was "
"automatically generated based on the "
":class:`~sqlalchemy.schema.ForeignKey` object which we placed on the "
"``addresses`` table way at the beginning of this tutorial. Already the "
"``join()`` construct is looking like a much better way to join tables."
msgstr ""

#: ../../core/tutorial.rst:1188
msgid ""
"Of course you can join on whatever expression you want, such as if we "
"want to join on all users who use the same name in their email address as"
" their username:"
msgstr ""

#: ../../core/tutorial.rst:1200
msgid ""
"When we create a :func:`.select` construct, SQLAlchemy looks around at "
"the tables we've mentioned and then places them in the FROM clause of the"
" statement. When we use JOINs however, we know what FROM clause we want, "
"so here we make use of the :meth:`~.Select.select_from` method:"
msgstr ""

#: ../../core/tutorial.rst:1217
msgid ""
"The :meth:`~.FromClause.outerjoin` method creates ``LEFT OUTER JOIN`` "
"constructs, and is used in the same way as :meth:`~.FromClause.join`:"
msgstr ""

#: ../../core/tutorial.rst:1228
msgid ""
"That's the output ``outerjoin()`` produces, unless, of course, you're "
"stuck in a gig using Oracle prior to version 9, and you've set up your "
"engine (which would be using ``OracleDialect``) to use Oracle-specific "
"SQL:"
msgstr ""

#: ../../core/tutorial.rst:1240
msgid ""
"If you don't know what that SQL means, don't worry ! The secret tribe of "
"Oracle DBAs don't want their black magic being found out ;)."
msgstr ""

#: ../../core/tutorial.rst:1245
msgid ":func:`.expression.join`"
msgstr ""

#: ../../core/tutorial.rst:1247
msgid ":func:`.expression.outerjoin`"
msgstr ""

#: ../../core/tutorial.rst:1249
msgid ":class:`.Join`"
msgstr ""

#: ../../core/tutorial.rst:1252
msgid "Everything Else"
msgstr ""

#: ../../core/tutorial.rst:1254
msgid ""
"The concepts of creating SQL expressions have been introduced. What's "
"left are more variants of the same themes. So now we'll catalog the rest "
"of the important things we'll need to know."
msgstr ""

#: ../../core/tutorial.rst:1261
msgid "Bind Parameter Objects"
msgstr ""

#: ../../core/tutorial.rst:1263
msgid ""
"Throughout all these examples, SQLAlchemy is busy creating bind "
"parameters wherever literal expressions occur. You can also specify your "
"own bind parameters with your own names, and use the same statement "
"repeatedly. The :func:`.bindparam` construct is used to produce a bound "
"parameter with a given name.  While SQLAlchemy always refers to bound "
"parameters by name on the API side, the database dialect converts to the "
"appropriate named or positional style at execution time, as here where it"
" converts to positional for SQLite:"
msgstr ""

#: ../../core/tutorial.rst:1283
msgid ""
"Another important aspect of :func:`.bindparam` is that it may be assigned"
" a type. The type of the bind parameter will determine its behavior "
"within expressions and also how the data bound to it is processed before "
"being sent off to the database:"
msgstr ""

#: ../../core/tutorial.rst:1299
msgid ""
":func:`.bindparam` constructs of the same name can also be used multiple "
"times, where only a single named value is needed in the execute "
"parameters:"
msgstr ""

#: ../../core/tutorial.rst:1326
msgid ":func:`.bindparam`"
msgstr ""

#: ../../core/tutorial.rst:1329
msgid "Functions"
msgstr ""

#: ../../core/tutorial.rst:1331
msgid ""
"SQL functions are created using the :data:`~.expression.func` keyword, "
"which generates functions using attribute access:"
msgstr ""

#: ../../core/tutorial.rst:1343
msgid ""
"By \"generates\", we mean that **any** SQL function is created based on "
"the word you choose::"
msgstr ""

#: ../../core/tutorial.rst:1349
msgid ""
"Certain function names are known by SQLAlchemy, allowing special "
"behavioral rules to be applied. Some for example are \"ANSI\" functions, "
"which mean they don't get the parenthesis added after them, such as "
"CURRENT_TIMESTAMP:"
msgstr ""

#: ../../core/tutorial.rst:1358
msgid ""
"Functions are most typically used in the columns clause of a select "
"statement, and can also be labeled as well as given a type. Labeling a "
"function is recommended so that the result can be targeted in a result "
"row based on a string name, and assigning it a type is required when you "
"need result-set processing to occur, such as for Unicode conversion and "
"date conversions. Below, we use the result function ``scalar()`` to just "
"read the first column of the first row and then close the result; the "
"label, even though present, is not important in this case:"
msgstr ""

#: ../../core/tutorial.rst:1380
msgid ""
"Databases such as PostgreSQL and Oracle which support functions that "
"return whole result sets can be assembled into selectable units, which "
"can be used in statements. Such as, a database function ``calculate()`` "
"which takes the parameters ``x`` and ``y``, and returns three columns "
"which we'd like to name ``q``, ``z`` and ``r``, we can construct using "
"\"lexical\" column objects as well as bind parameters:"
msgstr ""

#: ../../core/tutorial.rst:1404
msgid ""
"If we wanted to use our ``calculate`` statement twice with different bind"
" parameters, the "
":func:`~sqlalchemy.sql.expression.ClauseElement.unique_params` function "
"will create copies for us, and mark the bind parameters as \"unique\" so "
"that conflicting names are isolated. Note we also make two separate "
"aliases of our selectable:"
msgstr ""

#: ../../core/tutorial.rst:1428
msgid ":data:`.func`"
msgstr ""

#: ../../core/tutorial.rst:1433
msgid "Window Functions"
msgstr ""

#: ../../core/tutorial.rst:1435
msgid ""
"Any :class:`.FunctionElement`, including functions generated by "
":data:`~.expression.func`, can be turned into a \"window function\", that"
" is an OVER clause, using the :meth:`.FunctionElement.over` method::"
msgstr ""

#: ../../core/tutorial.rst:1447
msgid ""
":meth:`.FunctionElement.over` also supports range specification using "
"either the :paramref:`.expression.over.rows` or "
":paramref:`.expression.over.range` parameters::"
msgstr ""

#: ../../core/tutorial.rst:1462
msgid ""
":paramref:`.expression.over.rows` and :paramref:`.expression.over.range` "
"each accept a two-tuple which contains a combination of negative and "
"positive integers for ranges, zero to indicate \"CURRENT ROW\" and "
"``None`` to indicate \"UNBOUNDED\".  See the examples at :func:`.over` "
"for more detail."
msgstr ""

#: ../../core/tutorial.rst:1467
msgid "support for \"rows\" and \"range\" specification for window functions"
msgstr ""

#: ../../core/tutorial.rst:1472
msgid ":func:`.over`"
msgstr ""

#: ../../core/tutorial.rst:1474
msgid ":meth:`.FunctionElement.over`"
msgstr ""

#: ../../core/tutorial.rst:1477
msgid "Unions and Other Set Operations"
msgstr ""

#: ../../core/tutorial.rst:1479
msgid ""
"Unions come in two flavors, UNION and UNION ALL, which are available via "
"module level functions :func:`~.expression.union` and "
":func:`~.expression.union_all`:"
msgstr ""

#: ../../core/tutorial.rst:1504
msgid ""
"Also available, though not supported on all databases, are "
":func:`~.expression.intersect`, :func:`~.expression.intersect_all`, "
":func:`~.expression.except_`, and :func:`~.expression.except_all`:"
msgstr ""

#: ../../core/tutorial.rst:1530
msgid ""
"A common issue with so-called \"compound\" selectables arises due to the "
"fact that they nest with parenthesis. SQLite in particular doesn't like a"
" statement that starts with parenthesis. So when nesting a \"compound\" "
"inside a \"compound\", it's often necessary to apply "
"``.alias().select()`` to the first element of the outermost compound, if "
"that element is also a compound. For example, to nest a \"union\" and a "
"\"select\" inside of \"except\\_\", SQLite will want the \"union\" to be "
"stated as a subquery:"
msgstr ""

#: ../../core/tutorial.rst:1570
msgid ":func:`.union`"
msgstr ""

#: ../../core/tutorial.rst:1572
msgid ":func:`.union_all`"
msgstr ""

#: ../../core/tutorial.rst:1574
msgid ":func:`.intersect`"
msgstr ""

#: ../../core/tutorial.rst:1576
msgid ":func:`.intersect_all`"
msgstr ""

#: ../../core/tutorial.rst:1578
msgid ":func:`.except_`"
msgstr ""

#: ../../core/tutorial.rst:1580
msgid ":func:`.except_all`"
msgstr ""

#: ../../core/tutorial.rst:1585
msgid "Scalar Selects"
msgstr ""

#: ../../core/tutorial.rst:1587
msgid ""
"A scalar select is a SELECT that returns exactly one row and one column."
"  It can then be used as a column expression.  A scalar select is often a"
" :term:`correlated subquery`, which relies upon the enclosing SELECT "
"statement in order to acquire at least one of its FROM clauses."
msgstr ""

#: ../../core/tutorial.rst:1592
msgid ""
"The :func:`.select` construct can be modified to act as a column "
"expression by calling either the :meth:`~.SelectBase.as_scalar` or "
":meth:`~.SelectBase.label` method:"
msgstr ""

#: ../../core/tutorial.rst:1602
msgid ""
"The above construct is now a :class:`~.expression.ScalarSelect` object, "
"and is no longer part of the :class:`~.expression.FromClause` hierarchy; "
"it instead is within the :class:`~.expression.ColumnElement` family of "
"expression constructs.  We can place this construct the same as any other"
" column within another :func:`.select`:"
msgstr ""

#: ../../core/tutorial.rst:1618
msgid ""
"To apply a non-anonymous column name to our scalar select, we create it "
"using :meth:`.SelectBase.label` instead:"
msgstr ""

#: ../../core/tutorial.rst:1636
msgid ":meth:`.Select.as_scalar`"
msgstr ""

#: ../../core/tutorial.rst:1638
msgid ":meth:`.Select.label`"
msgstr ""

#: ../../core/tutorial.rst:1643
msgid "Correlated Subqueries"
msgstr ""

#: ../../core/tutorial.rst:1645
msgid ""
"Notice in the examples on :ref:`scalar_selects`, the FROM clause of each "
"embedded select did not contain the ``users`` table in its FROM clause. "
"This is because SQLAlchemy automatically :term:`correlates` embedded FROM"
" objects to that of an enclosing query, if present, and if the inner "
"SELECT statement would still have at least one FROM clause of its own.  "
"For example:"
msgstr ""

#: ../../core/tutorial.rst:1667
msgid ""
"Auto-correlation will usually do what's expected, however it can also be "
"controlled. For example, if we wanted a statement to correlate only to "
"the ``addresses`` table but not the ``users`` table, even if both were "
"present in the enclosing SELECT, we use the :meth:`~.Select.correlate` "
"method to specify those FROM clauses that may be correlated:"
msgstr ""

#: ../../core/tutorial.rst:1692
msgid ""
"To entirely disable a statement from correlating, we can pass ``None`` as"
" the argument:"
msgstr ""

#: ../../core/tutorial.rst:1711
msgid ""
"We can also control correlation via exclusion, using the "
":meth:`.Select.correlate_except` method.   Such as, we can write our "
"SELECT for the ``users`` table by telling it to correlate all FROM "
"clauses except for ``users``:"
msgstr ""

#: ../../core/tutorial.rst:1737
msgid "LATERAL correlation"
msgstr ""

#: ../../core/tutorial.rst:1739
msgid ""
"LATERAL correlation is a special sub-category of SQL correlation which "
"allows a selectable unit to refer to another selectable unit within a "
"single FROM clause.  This is an extremely special use case which, while "
"part of the SQL standard, is only known to be supported by recent "
"versions of PostgreSQL."
msgstr ""

#: ../../core/tutorial.rst:1745
msgid ""
"Normally, if a SELECT statement refers to ``table1 JOIN (some SELECT) AS "
"subquery`` in its FROM clause, the subquery on the right side may not "
"refer to the \"table1\" expression from the left side; correlation may "
"only refer to a table that is part of another SELECT that entirely "
"encloses this SELECT.  The LATERAL keyword allows us to turn this "
"behavior around, allowing an expression such as:"
msgstr ""

#: ../../core/tutorial.rst:1759
msgid ""
"Where above, the right side of the JOIN contains a subquery that refers "
"not just to the \"books\" table but also the \"people\" table, "
"correlating to the left side of the JOIN.   SQLAlchemy Core supports a "
"statement like the above using the :meth:`.Select.lateral` method as "
"follows::"
msgstr ""

#: ../../core/tutorial.rst:1775
msgid ""
"Above, we can see that the :meth:`.Select.lateral` method acts a lot like"
" the :meth:`.Select.alias` method, including that we can specify an "
"optional name.  However the construct is the :class:`.Lateral` construct "
"instead of an :class:`.Alias` which provides for the LATERAL keyword as "
"well as special instructions to allow correlation from inside the FROM "
"clause of the enclosing statement."
msgstr ""

#: ../../core/tutorial.rst:1782
msgid ""
"The :meth:`.Select.lateral` method interacts normally with the "
":meth:`.Select.correlate` and :meth:`.Select.correlate_except` methods, "
"except that the correlation rules also apply to any other tables present "
"in the enclosing statement's FROM clause.   Correlation is \"automatic\" "
"to these tables by default, is explicit if the table is specified to "
":meth:`.Select.correlate`, and is explicit to all tables except those "
"specified to :meth:`.Select.correlate_except`."
msgstr ""

#: ../../core/tutorial.rst:1793
msgid "Support for the LATERAL keyword and lateral correlation."
msgstr ""

#: ../../core/tutorial.rst:1797
msgid ":class:`.Lateral`"
msgstr ""

#: ../../core/tutorial.rst:1799
msgid ":meth:`.Select.lateral`"
msgstr ""

#: ../../core/tutorial.rst:1803
msgid "Ordering, Grouping, Limiting, Offset...ing..."
msgstr ""

#: ../../core/tutorial.rst:1805
msgid ""
"Ordering is done by passing column expressions to the "
":meth:`~.SelectBase.order_by` method:"
msgstr ""

#: ../../core/tutorial.rst:1817
msgid ""
"Ascending or descending can be controlled using the "
":meth:`~.ColumnElement.asc` and :meth:`~.ColumnElement.desc` modifiers:"
msgstr ""

#: ../../core/tutorial.rst:1829
msgid ""
"Grouping refers to the GROUP BY clause, and is usually used in "
"conjunction with aggregate functions to establish groups of rows to be "
"aggregated. This is provided via the :meth:`~.SelectBase.group_by` "
"method:"
msgstr ""

#: ../../core/tutorial.rst:1846
msgid ""
"HAVING can be used to filter results on an aggregate value, after GROUP "
"BY has been applied.  It's available here via the :meth:`~.Select.having`"
" method:"
msgstr ""

#: ../../core/tutorial.rst:1865
msgid ""
"A common system of dealing with duplicates in composed SELECT statements "
"is the DISTINCT modifier.  A simple DISTINCT clause can be added using "
"the :meth:`.Select.distinct` method:"
msgstr ""

#: ../../core/tutorial.rst:1882
msgid ""
"Most database backends support a system of limiting how many rows are "
"returned, and the majority also feature a means of starting to return "
"rows after a given \"offset\".   While common backends like PostgreSQL, "
"MySQL and SQLite support LIMIT and OFFSET keywords, other backends need "
"to refer to more esoteric features such as \"window functions\" and row "
"ids to achieve the same effect.  The :meth:`~.Select.limit` and "
":meth:`~.Select.offset` methods provide an easy abstraction into the "
"current backend's methodology:"
msgstr ""

#: ../../core/tutorial.rst:1907
msgid "Inserts, Updates and Deletes"
msgstr ""

#: ../../core/tutorial.rst:1909
msgid ""
"We've seen :meth:`~.TableClause.insert` demonstrated earlier in this "
"tutorial.   Where :meth:`~.TableClause.insert` produces INSERT, the "
":meth:`~.TableClause.update` method produces UPDATE.  Both of these "
"constructs feature a method called :meth:`~.ValuesBase.values` which "
"specifies the VALUES or SET clause of the statement."
msgstr ""

#: ../../core/tutorial.rst:1916
msgid ""
"The :meth:`~.ValuesBase.values` method accommodates any column expression"
" as a value:"
msgstr ""

#: ../../core/tutorial.rst:1929
msgid ""
"When using :meth:`~.TableClause.insert` or :meth:`~.TableClause.update` "
"in an \"execute many\" context, we may also want to specify named bound "
"parameters which we can refer to in the argument list. The two constructs"
" will automatically generate bound placeholders for any column names "
"passed in the dictionaries sent to :meth:`~.Connection.execute` at "
"execution time.  However, if we wish to use explicitly targeted named "
"parameters with composed expressions, we need to use the "
":func:`~.expression.bindparam` construct. When using "
":func:`~.expression.bindparam` with :meth:`~.TableClause.insert` or "
":meth:`~.TableClause.update`, the names of the table's columns themselves"
" are reserved for the \"automatic\" generation of bind names.  We can "
"combine the usage of implicitly available bind names and explicitly named"
" parameters as in the example below:"
msgstr ""

#: ../../core/tutorial.rst:1958
msgid ""
"An UPDATE statement is emitted using the :meth:`~.TableClause.update` "
"construct.  This works much like an INSERT, except there is an additional"
" WHERE clause that can be specified:"
msgstr ""

#: ../../core/tutorial.rst:1974
msgid ""
"When using :meth:`~.TableClause.update` in an \"executemany\" context, we"
" may wish to also use explicitly named bound parameters in the WHERE "
"clause.  Again, :func:`~.expression.bindparam` is the construct used to "
"achieve this:"
msgstr ""

#: ../../core/tutorial.rst:1996
msgid "Correlated Updates"
msgstr ""

#: ../../core/tutorial.rst:1998
msgid ""
"A correlated update lets you update a table using selection from another "
"table, or the same table:"
msgstr ""

#: ../../core/tutorial.rst:2018
msgid "Multiple Table Updates"
msgstr ""

#: ../../core/tutorial.rst:2022
msgid ""
"The PostgreSQL, Microsoft SQL Server, and MySQL backends all support "
"UPDATE statements that refer to multiple tables.   For PG and MSSQL, this"
" is the \"UPDATE FROM\" syntax, which updates one table at a time, but "
"can reference additional tables in an additional \"FROM\" clause that can"
" then be referenced in the WHERE clause directly.   On MySQL, multiple "
"tables can be embedded into a single UPDATE statement separated by a "
"comma. The SQLAlchemy :func:`.update` construct supports both of these "
"modes implicitly, by specifying multiple tables in the WHERE clause::"
msgstr ""

#: ../../core/tutorial.rst:2036
msgid "The resulting SQL from the above statement would render as::"
msgstr ""

#: ../../core/tutorial.rst:2042
msgid ""
"When using MySQL, columns from each table can be assigned to in the SET "
"clause directly, using the dictionary form passed to "
":meth:`.Update.values`::"
msgstr ""

#: ../../core/tutorial.rst:2053
msgid "The tables are referenced explicitly in the SET clause::"
msgstr ""

#: ../../core/tutorial.rst:2059 ../../core/tutorial.rst:2164
msgid ""
"When the construct is used on a non-supporting database, the compiler "
"will raise ``NotImplementedError``.   For convenience, when a statement "
"is printed as a string without specification of a dialect, the \"string "
"SQL\" compiler will be invoked which provides a non-working SQL "
"representation of the construct."
msgstr ""

#: ../../core/tutorial.rst:2068
msgid "Parameter-Ordered Updates"
msgstr ""

#: ../../core/tutorial.rst:2070
msgid ""
"The default behavior of the :func:`.update` construct when rendering the "
"SET clauses is to render them using the column ordering given in the "
"originating :class:`.Table` object. This is an important behavior, since "
"it means that the rendering of a particular UPDATE statement with "
"particular columns will be rendered the same each time, which has an "
"impact on query caching systems that rely on the form of the statement, "
"either client side or server side. Since the parameters themselves are "
"passed to the :meth:`.Update.values` method as Python dictionary keys, "
"there is no other fixed ordering available."
msgstr ""

#: ../../core/tutorial.rst:2081
msgid ""
"However in some cases, the order of parameters rendered in the SET clause"
" of an UPDATE statement can be significant.  The main example of this is "
"when using MySQL and providing updates to column values based on that of "
"other column values.  The end result of the following statement::"
msgstr ""

#: ../../core/tutorial.rst:2088
msgid "Will have a different result than::"
msgstr ""

#: ../../core/tutorial.rst:2092
msgid ""
"This because on MySQL, the individual SET clauses are fully evaluated on "
"a per-value basis, as opposed to on a per-row basis, and as each SET "
"clause is evaluated, the values embedded in the row are changing."
msgstr ""

#: ../../core/tutorial.rst:2096
msgid ""
"To suit this specific use case, the "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order` "
"flag may be used.  When using this flag, we supply a **Python list of "
"2-tuples** as the argument to the :meth:`.Update.values` method::"
msgstr ""

#: ../../core/tutorial.rst:2104
msgid ""
"The list of 2-tuples is essentially the same structure as a Python "
"dictionary except it is ordered.  Using the above form, we are assured "
"that the \"y\" column's SET clause will render first, then the \"x\" "
"column's SET clause."
msgstr ""

#: ../../core/tutorial.rst:2108
msgid ""
"Added support for explicit ordering of UPDATE parameters using the "
":paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order` "
"flag."
msgstr ""

#: ../../core/tutorial.rst:2114
msgid ""
":ref:`mysql_insert_on_duplicate_key_update` - background on the MySQL "
"``ON DUPLICATE KEY UPDATE`` clause and how to support parameter ordering."
msgstr ""

#: ../../core/tutorial.rst:2120
msgid "Deletes"
msgstr ""

#: ../../core/tutorial.rst:2122
msgid ""
"Finally, a delete.  This is accomplished easily enough using the "
":meth:`~.TableClause.delete` construct:"
msgstr ""

#: ../../core/tutorial.rst:2142
msgid "Multiple Table Deletes"
msgstr ""

#: ../../core/tutorial.rst:2146
msgid ""
"The PostgreSQL, Microsoft SQL Server, and MySQL backends all support "
"DELETE statements that refer to multiple tables within the WHERE "
"criteria.   For PG and MySQL, this is the \"DELETE USING\" syntax, and "
"for SQL Server, it's a \"DELETE FROM\" that refers to more than one "
"table.  The SQLAlchemy :func:`.delete` construct supports both of these "
"modes implicitly, by specifying multiple tables in the WHERE clause::"
msgstr ""

#: ../../core/tutorial.rst:2158
msgid ""
"On a Postgresql backend, the resulting SQL from the above statement would"
" render as::"
msgstr ""

#: ../../core/tutorial.rst:2171
msgid "Matched Row Counts"
msgstr ""

#: ../../core/tutorial.rst:2173
msgid ""
"Both of :meth:`~.TableClause.update` and :meth:`~.TableClause.delete` are"
" associated with *matched row counts*.  This is a number indicating the "
"number of rows that were matched by the WHERE clause. Note that by "
"\"matched\", this includes rows where no UPDATE actually took place. The "
"value is available as :attr:`~.ResultProxy.rowcount`:"
msgstr ""

#: ../../core/tutorial.rst:2189
msgid "Further Reference"
msgstr ""

#: ../../core/tutorial.rst:2191
msgid "Expression Language Reference: :ref:`expression_api_toplevel`"
msgstr ""

#: ../../core/tutorial.rst:2193
msgid "Database Metadata Reference: :ref:`metadata_toplevel`"
msgstr ""

#: ../../core/tutorial.rst:2195
msgid "Engine Reference: :doc:`/core/engines`"
msgstr ""

#: ../../core/tutorial.rst:2197
msgid "Connection Reference: :ref:`connections_toplevel`"
msgstr ""

#: ../../core/tutorial.rst:2199
msgid "Types Reference: :ref:`types_toplevel`"
msgstr ""

